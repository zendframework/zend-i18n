{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"filters/","text":"Filters zend-i18n ships with a set of internationalization-related filters. Alnum The Alnum filter can be used to return only alphabetic characters and digits in the unicode \"letter\" and \"number\" categories, respectively. All other characters are suppressed. Supported Options The following options are supported for Alnum : Alnum([ boolean $allowWhiteSpace [, string $locale ]]) $allowWhiteSpace : If set to true, whitespace characters are allowed; otherwise they are suppressed. Default is false (whitespace is not allowed). Methods for getting/setting the allowWhiteSpace option are also available ( getAllowWhiteSpace() and setAllowWhiteSpace() ). $locale : The locale string used in identifying the characters to filter (locale name, e.g. en_US ). If unset, it will use the default locale ( Locale::getDefault() ). Methods for getting/setting the locale are also available ( getLocale() and setLocale() ). Basic Usage // Default settings, deny whitespace $filter = new \\Zend\\I18n\\Filter\\Alnum(); echo $filter->filter(\"This is (my) content: 123\"); // Returns \"Thisismycontent123\" // First param in constructor is $allowWhiteSpace $filter = new \\Zend\\I18n\\Filter\\Alnum(true); echo $filter->filter(\"This is (my) content: 123\"); // Returns \"This is my content 123\" Supported languages Alnum works for most languages, except Chinese, Japanese and Korean. Within these languages, the English alphabet is used instead of the characters from these languages. The language itself is detected using the Locale class. Alpha The Alpha filter can be used to return only alphabetic characters in the unicode \"letter\" category. All other characters are suppressed. Supported Options The following options are supported for Alpha : Alpha([ boolean $allowWhiteSpace [, string $locale ]]) $allowWhiteSpace : If set to true, whitespace characters are allowed; otherwise they are suppressed. Default is false (whitespace is not allowed). Methods for getting/setting the allowWhiteSpace option are also available ( getAllowWhiteSpace() and setAllowWhiteSpace() ). $locale : The locale string used in identifying the characters to filter (locale name, e.g. en_US ). If unset, it will use the default locale ( Locale::getDefault() ). Methods for getting/setting the locale are also available ( getLocale() and setLocale() ). Basic Usage // Default settings, deny whitespace $filter = new \\Zend\\I18n\\Filter\\Alpha(); echo $filter->filter(\"This is (my) content: 123\"); // Returns \"Thisismycontent\" // Allow whitespace $filter = new \\Zend\\I18n\\Filter\\Alpha(true); echo $filter->filter(\"This is (my) content: 123\"); // Returns \"This is my content \" Supported languages Alnum works for most languages, except Chinese, Japanese and Korean. Within these languages, the English alphabet is used instead of the characters from these languages. The language itself is detected using the Locale class. NumberFormat The NumberFormat filter can be used to return locale-specific number and percentage strings. It extends the NumberParse filter, which acts as wrapper for the NumberFormatter class within ext/intl. Supported Options The following options are supported for NumberFormat : NumberFormat([ string $locale [, int $style [, int $type ]]]) $locale : The locale string used in identifying the characters to filter (locale name, e.g. en_US ). If unset, it will use the default locale ( Locale::getDefault() ). Methods for getting/setting the locale are also available ( getLocale() and setLocale() ). $style : (Optional) Style of the formatting, one of the NumberFormatter format style constants . If unset, it will use NumberFormatter::DEFAULT_STYLE as the default style. Methods for getting/setting the format style are also available ( getStyle() and setStyle() ). $type : (Optional) The NumberFormatter formatting type to use. If unset, it will use NumberFormatter::TYPE_DOUBLE as the default type. Methods for getting/setting the format type are also available ( getType() and setType() ). Basic Usage $filter = new \\Zend\\I18n\\Filter\\NumberFormat('de_DE'); echo $filter->filter(1234567.8912346); // Returns \"1.234.567,891\" $filter = new \\Zend\\I18n\\Filter\\NumberFormat('en_US', NumberFormatter::PERCENT); echo $filter->filter(0.80); // Returns \"80%\" $filter = new \\Zend\\I18n\\Filter\\NumberFormat('fr_FR', NumberFormatter::SCIENTIFIC); echo $filter->filter(0.00123456789); // Returns \"1,23456789E-3\" NumberParse The NumberParse filter can be used to parse a number from a string. It acts as a wrapper for the NumberFormatter class within ext/intl. Supported Options The following options are supported for NumberParse : NumberParse([ string $locale [, int $style [, int $type ]]]) $locale : The locale string used in identifying the characters to filter (locale name, e.g. en_US ). If unset, it will use the default locale ( Locale::getDefault() ). Methods for getting/setting the locale are also available ( getLocale() and setLocale() ). $style : (Optional) Style of the parsing, one of the NumberFormatter format style constants . If unset, it will use NumberFormatter::DEFAULT_STYLE as the default style. Methods for getting/setting the parse style are also available ( getStyle() and setStyle() ). $type : (Optional) The NumberFormatter parsing type to use. If unset, it will use NumberFormatter::TYPE_DOUBLE as the default type. Methods for getting/setting the parse type are also available ( getType() and setType() ). Basic Usage $filter = new \\Zend\\I18n\\Filter\\NumberParse('de_DE'); echo $filter->filter('1.234.567,891'); // Returns 1234567.8912346 $filter = new \\Zend\\I18n\\Filter\\NumberParse('en_US', NumberFormatter::PERCENT); echo $filter->filter('80%'); // Returns 0.80 $filter = new \\Zend\\I18n\\Filter\\NumberParse('fr_FR', NumberFormatter::SCIENTIFIC); echo $filter->filter('1,23456789E-3'); // Returns 0.00123456789","title":"Filters"},{"location":"filters/#filters","text":"zend-i18n ships with a set of internationalization-related filters.","title":"Filters"},{"location":"filters/#alnum","text":"The Alnum filter can be used to return only alphabetic characters and digits in the unicode \"letter\" and \"number\" categories, respectively. All other characters are suppressed.","title":"Alnum"},{"location":"filters/#supported-options","text":"The following options are supported for Alnum : Alnum([ boolean $allowWhiteSpace [, string $locale ]]) $allowWhiteSpace : If set to true, whitespace characters are allowed; otherwise they are suppressed. Default is false (whitespace is not allowed). Methods for getting/setting the allowWhiteSpace option are also available ( getAllowWhiteSpace() and setAllowWhiteSpace() ). $locale : The locale string used in identifying the characters to filter (locale name, e.g. en_US ). If unset, it will use the default locale ( Locale::getDefault() ). Methods for getting/setting the locale are also available ( getLocale() and setLocale() ).","title":"Supported Options"},{"location":"filters/#basic-usage","text":"// Default settings, deny whitespace $filter = new \\Zend\\I18n\\Filter\\Alnum(); echo $filter->filter(\"This is (my) content: 123\"); // Returns \"Thisismycontent123\" // First param in constructor is $allowWhiteSpace $filter = new \\Zend\\I18n\\Filter\\Alnum(true); echo $filter->filter(\"This is (my) content: 123\"); // Returns \"This is my content 123\"","title":"Basic Usage"},{"location":"filters/#supported-languages","text":"Alnum works for most languages, except Chinese, Japanese and Korean. Within these languages, the English alphabet is used instead of the characters from these languages. The language itself is detected using the Locale class.","title":"Supported languages"},{"location":"filters/#alpha","text":"The Alpha filter can be used to return only alphabetic characters in the unicode \"letter\" category. All other characters are suppressed.","title":"Alpha"},{"location":"filters/#supported-options_1","text":"The following options are supported for Alpha : Alpha([ boolean $allowWhiteSpace [, string $locale ]]) $allowWhiteSpace : If set to true, whitespace characters are allowed; otherwise they are suppressed. Default is false (whitespace is not allowed). Methods for getting/setting the allowWhiteSpace option are also available ( getAllowWhiteSpace() and setAllowWhiteSpace() ). $locale : The locale string used in identifying the characters to filter (locale name, e.g. en_US ). If unset, it will use the default locale ( Locale::getDefault() ). Methods for getting/setting the locale are also available ( getLocale() and setLocale() ).","title":"Supported Options"},{"location":"filters/#basic-usage_1","text":"// Default settings, deny whitespace $filter = new \\Zend\\I18n\\Filter\\Alpha(); echo $filter->filter(\"This is (my) content: 123\"); // Returns \"Thisismycontent\" // Allow whitespace $filter = new \\Zend\\I18n\\Filter\\Alpha(true); echo $filter->filter(\"This is (my) content: 123\"); // Returns \"This is my content \"","title":"Basic Usage"},{"location":"filters/#supported-languages_1","text":"Alnum works for most languages, except Chinese, Japanese and Korean. Within these languages, the English alphabet is used instead of the characters from these languages. The language itself is detected using the Locale class.","title":"Supported languages"},{"location":"filters/#numberformat","text":"The NumberFormat filter can be used to return locale-specific number and percentage strings. It extends the NumberParse filter, which acts as wrapper for the NumberFormatter class within ext/intl.","title":"NumberFormat"},{"location":"filters/#supported-options_2","text":"The following options are supported for NumberFormat : NumberFormat([ string $locale [, int $style [, int $type ]]]) $locale : The locale string used in identifying the characters to filter (locale name, e.g. en_US ). If unset, it will use the default locale ( Locale::getDefault() ). Methods for getting/setting the locale are also available ( getLocale() and setLocale() ). $style : (Optional) Style of the formatting, one of the NumberFormatter format style constants . If unset, it will use NumberFormatter::DEFAULT_STYLE as the default style. Methods for getting/setting the format style are also available ( getStyle() and setStyle() ). $type : (Optional) The NumberFormatter formatting type to use. If unset, it will use NumberFormatter::TYPE_DOUBLE as the default type. Methods for getting/setting the format type are also available ( getType() and setType() ).","title":"Supported Options"},{"location":"filters/#basic-usage_2","text":"$filter = new \\Zend\\I18n\\Filter\\NumberFormat('de_DE'); echo $filter->filter(1234567.8912346); // Returns \"1.234.567,891\" $filter = new \\Zend\\I18n\\Filter\\NumberFormat('en_US', NumberFormatter::PERCENT); echo $filter->filter(0.80); // Returns \"80%\" $filter = new \\Zend\\I18n\\Filter\\NumberFormat('fr_FR', NumberFormatter::SCIENTIFIC); echo $filter->filter(0.00123456789); // Returns \"1,23456789E-3\"","title":"Basic Usage"},{"location":"filters/#numberparse","text":"The NumberParse filter can be used to parse a number from a string. It acts as a wrapper for the NumberFormatter class within ext/intl.","title":"NumberParse"},{"location":"filters/#supported-options_3","text":"The following options are supported for NumberParse : NumberParse([ string $locale [, int $style [, int $type ]]]) $locale : The locale string used in identifying the characters to filter (locale name, e.g. en_US ). If unset, it will use the default locale ( Locale::getDefault() ). Methods for getting/setting the locale are also available ( getLocale() and setLocale() ). $style : (Optional) Style of the parsing, one of the NumberFormatter format style constants . If unset, it will use NumberFormatter::DEFAULT_STYLE as the default style. Methods for getting/setting the parse style are also available ( getStyle() and setStyle() ). $type : (Optional) The NumberFormatter parsing type to use. If unset, it will use NumberFormatter::TYPE_DOUBLE as the default type. Methods for getting/setting the parse type are also available ( getType() and setType() ).","title":"Supported Options"},{"location":"filters/#basic-usage_3","text":"$filter = new \\Zend\\I18n\\Filter\\NumberParse('de_DE'); echo $filter->filter('1.234.567,891'); // Returns 1234567.8912346 $filter = new \\Zend\\I18n\\Filter\\NumberParse('en_US', NumberFormatter::PERCENT); echo $filter->filter('80%'); // Returns 0.80 $filter = new \\Zend\\I18n\\Filter\\NumberParse('fr_FR', NumberFormatter::SCIENTIFIC); echo $filter->filter('1,23456789E-3'); // Returns 0.00123456789","title":"Basic Usage"},{"location":"introduction/","text":"Introduction Zend\\I18n comes with a complete translation suite which supports all major formats and includes popular features like plural translations and text domains. The Translator component is mostly dependency free, except for the fallback to a default locale, where it relies on the Intl PHP extension. The translator itself is initialized without any parameters, as any configuration to it is optional. A translator without any translations will actually do nothing but just return the given message IDs.","title":"Introduction"},{"location":"introduction/#introduction","text":"Zend\\I18n comes with a complete translation suite which supports all major formats and includes popular features like plural translations and text domains. The Translator component is mostly dependency free, except for the fallback to a default locale, where it relies on the Intl PHP extension. The translator itself is initialized without any parameters, as any configuration to it is optional. A translator without any translations will actually do nothing but just return the given message IDs.","title":"Introduction"},{"location":"translation/","text":"Translation zend-i18n comes with a complete translation suite supporting all major formats and including popular features such as plural translations and text domains. The Translator subcomponent is mostly dependency free, except for the fallback to a default locale, where it relies on the PHP's intl extension. The translator itself is initialized without any parameters, as any configuration to it is optional. A translator without any translations will do nothing but return all messages verbatim. Adding translations Two options exist for adding translations to the translator: Add every translation file individually; use this for translation formats that store multiple locales in the same file. Add translation files based on a pattern; use this for formats that use one file per locale. To add a single file to the translator, use the addTranslationFile() method: use Zend\\I18n\\Translator\\Translator; $translator = new Translator(); $translator->addTranslationFile($type, $filename, $textDomain, $locale); where the arguments are: $type : the name of the format loader to use; see the next section for details. $filename : the file containing translations. $textDomain : a \"category\" name for translations. If this is omitted, it defaults to \"default\". Use text domains to segregate translations by context. $locale : the language strings are translated from; this argument is only required for formats which contain translations for single locales. When storing one locale per file, you should specify those files via a pattern. This allows you to add new translations to the file system, without touching your code. Patterns are added with the addTranslationFilePattern() method: use Zend\\I18n\\Translator\\Translator; $translator = new Translator(); $translator->addTranslationFilePattern($type, $baseDir, $pattern, $textDomain); where the arguments are roughly the same as for addTranslationFile() , with a few differences: $baseDir is a directory containing translation files. $pattern is an sprintf() -formatted string describing a pattern for locating files under $baseDir . The $pattern should contain a substitution character for the $locale \u2014 which is omitted from the addTranslationFilePattern() call, but passed whenever a translation is requested. Use either %s or %1$s in the $pattern as a placeholder for the locale. As an example, if your translation files are located in /var/messages/<LOCALE>/messages.mo , your pattern would be /var/messages/%s/messages.mo . Supported formats The translator supports the following major translation formats: PHP arrays Gettext INI Additionally, you can use custom formats by implementing one or more of Zend\\I18n\\Translator\\Loader\\FileLoaderInterface or Zend\\I18n\\Translator\\Loader\\RemoteLoaderInterface , and registering your loader with the Translator instance's composed plugin manager. Setting a locale By default, the translator will get the locale to use from ext/intl's Locale class. If you want to set an alternative locale explicitly, you can do so by passing it to the setLocale() method. When there is no translation for a specific message identifier in a locale, the message identifier itself will be returned by default. Alternately, you can set a fallback locale which is used to retrieve a fallback translation. To do so, pass it to the setFallbackLocale() method. Translating messages Translating messages is accomplished by calling the translate() method of the translator: $translator->translate($message, $textDomain, $locale); The message is the message identifier to translate. If it does not exist in the loader, or is empty, the original message ID will be returned. The text domain parameter is the one you specified when adding translations. If omitted, the \"default\" text domain will be used. The locale parameter will usually not be used in this context, as by default the locale is taken from the locale set in the translator. To translate plural messages, you can use the translatePlural() method. It works similarly to translate() , but instead of a single message, it takes a singular value, a plural value, and an additional integer number on which the returned plural form is based: $translator->translatePlural($singular, $plural, $number, $textDomain, $locale); Plural translations are only available if the underlying format supports the translation of plural messages and plural rule definitions. Caching In production, it makes sense to cache your translations. This not only saves you from loading and parsing the individual formats each time, but also guarantees an optimized loading procedure. To enable caching, pass a Zend\\Cache\\Storage\\Adapter to the setCache() method. To disable the cache, pass a null value to the method.","title":"Translation"},{"location":"translation/#translation","text":"zend-i18n comes with a complete translation suite supporting all major formats and including popular features such as plural translations and text domains. The Translator subcomponent is mostly dependency free, except for the fallback to a default locale, where it relies on the PHP's intl extension. The translator itself is initialized without any parameters, as any configuration to it is optional. A translator without any translations will do nothing but return all messages verbatim.","title":"Translation"},{"location":"translation/#adding-translations","text":"Two options exist for adding translations to the translator: Add every translation file individually; use this for translation formats that store multiple locales in the same file. Add translation files based on a pattern; use this for formats that use one file per locale. To add a single file to the translator, use the addTranslationFile() method: use Zend\\I18n\\Translator\\Translator; $translator = new Translator(); $translator->addTranslationFile($type, $filename, $textDomain, $locale); where the arguments are: $type : the name of the format loader to use; see the next section for details. $filename : the file containing translations. $textDomain : a \"category\" name for translations. If this is omitted, it defaults to \"default\". Use text domains to segregate translations by context. $locale : the language strings are translated from; this argument is only required for formats which contain translations for single locales. When storing one locale per file, you should specify those files via a pattern. This allows you to add new translations to the file system, without touching your code. Patterns are added with the addTranslationFilePattern() method: use Zend\\I18n\\Translator\\Translator; $translator = new Translator(); $translator->addTranslationFilePattern($type, $baseDir, $pattern, $textDomain); where the arguments are roughly the same as for addTranslationFile() , with a few differences: $baseDir is a directory containing translation files. $pattern is an sprintf() -formatted string describing a pattern for locating files under $baseDir . The $pattern should contain a substitution character for the $locale \u2014 which is omitted from the addTranslationFilePattern() call, but passed whenever a translation is requested. Use either %s or %1$s in the $pattern as a placeholder for the locale. As an example, if your translation files are located in /var/messages/<LOCALE>/messages.mo , your pattern would be /var/messages/%s/messages.mo .","title":"Adding translations"},{"location":"translation/#supported-formats","text":"The translator supports the following major translation formats: PHP arrays Gettext INI Additionally, you can use custom formats by implementing one or more of Zend\\I18n\\Translator\\Loader\\FileLoaderInterface or Zend\\I18n\\Translator\\Loader\\RemoteLoaderInterface , and registering your loader with the Translator instance's composed plugin manager.","title":"Supported formats"},{"location":"translation/#setting-a-locale","text":"By default, the translator will get the locale to use from ext/intl's Locale class. If you want to set an alternative locale explicitly, you can do so by passing it to the setLocale() method. When there is no translation for a specific message identifier in a locale, the message identifier itself will be returned by default. Alternately, you can set a fallback locale which is used to retrieve a fallback translation. To do so, pass it to the setFallbackLocale() method.","title":"Setting a locale"},{"location":"translation/#translating-messages","text":"Translating messages is accomplished by calling the translate() method of the translator: $translator->translate($message, $textDomain, $locale); The message is the message identifier to translate. If it does not exist in the loader, or is empty, the original message ID will be returned. The text domain parameter is the one you specified when adding translations. If omitted, the \"default\" text domain will be used. The locale parameter will usually not be used in this context, as by default the locale is taken from the locale set in the translator. To translate plural messages, you can use the translatePlural() method. It works similarly to translate() , but instead of a single message, it takes a singular value, a plural value, and an additional integer number on which the returned plural form is based: $translator->translatePlural($singular, $plural, $number, $textDomain, $locale); Plural translations are only available if the underlying format supports the translation of plural messages and plural rule definitions.","title":"Translating messages"},{"location":"translation/#caching","text":"In production, it makes sense to cache your translations. This not only saves you from loading and parsing the individual formats each time, but also guarantees an optimized loading procedure. To enable caching, pass a Zend\\Cache\\Storage\\Adapter to the setCache() method. To disable the cache, pass a null value to the method.","title":"Caching"},{"location":"validators/","text":"Validators zend-i18n provides a set of validators that use internationalization capabilities. Alnum Zend\\I18n\\Validator\\Alnum allows you to validate if a given value contains only alphabetical characters and digits. There is no length limitation for the input you want to validate. Supported options The following options are supported for Zend\\I18n\\Validator\\Alnum : allowWhiteSpace : Whether or not whitespace characters are allowed. This option defaults to FALSE . Basic usage $validator = new Zend\\I18n\\Validator\\Alnum(); if ($validator->isValid('Abcd12')) { // value contains only allowed chars } else { // false } Using whitespace By default, whitespace is not accepted as it is not part of the alphabet. However, if you want to validate complete sentences or phrases, you may need to allow whitespace; this can be done via the allowWhiteSpace option, either at instantiation or afterwards via the setAllowWhiteSpace() method. To get the current state of the flag, use the getAllowWhiteSpace() method. $validator = new Zend\\I18n\\Validator\\Alnum(['allowWhiteSpace' => true]); // or set it via method call: $validator->setAllowWhiteSpace(true); if ($validator->isValid('Abcd and 12')) { // value contains only allowed chars } else { // false } Using different languages Several languages supported by ext/intl use alphabets where characters are formed from multiple bytes, including Korean , Japanese , and Chinese . Such languages therefore are unsupported with regards to the Alnum validator. When using the Alnum validator with these languages, the input will be validated using the English alphabet. Alpha Zend\\I18n\\Validator\\Alpha allows you to validate if a given value contains only alphabetical characters. There is no length limitation for the input you want to validate. This validator is identical to the Zend\\I18n\\Validator\\Alnum validator with the exception that it does not accept digits. Supported options The following options are supported for Zend\\I18n\\Validator\\Alpha : allowWhiteSpace : Whether or not whitespace characters are allowed. This option defaults to FALSE . Basic usage $validator = new Zend\\I18n\\Validator\\Alpha(); if ($validator->isValid('Abcd')) { // value contains only allowed chars } else { // false } Using whitespace By default, whitespace is not accepted as it is not part of the alphabet. However, if you want to validate complete sentences or phrases, you may need to allow whitespace; this can be done via the allowWhiteSpace option, either at instantiation or afterwards via the setAllowWhiteSpace() method. To get the current state of the flag, use the getAllowWhiteSpace() method. $validator = new Zend\\I18n\\Validator\\Alpha(['allowWhiteSpace' => true]); // or set it via method call: $validator->setAllowWhiteSpace(true); if ($validator->isValid('Abcd and efg')) { // value contains only allowed chars } else { // false } Using different languages When using Zend\\I18n\\Validator\\Alpha , the language provided by the user's browser will be used to set the allowed characters. For locales outside of English, this means that additional alphabetic characters may be used \u2014 such as \u00e4 , \u00f6 and \u00fc from the German alphabet. Which characters are allowed depends completely on the language, as every language defines its own set of characters. Three languages supported by ext/intl, however, define multibyte characters, which cannot be matched as alphabetic characters using normal string or regular expression options. These include Korean , Japanese , and Chinese . As a result, when using the Alpha validator with these languages, the input will be validated using the English alphabet. IsFloat Zend\\I18n\\Validator\\IsFloat allows you to validate if a given value contains a floating-point value. This validator takes into account localized input. Supported options The following options are supported for Zend\\I18n\\Validator\\IsFloat : locale : Sets the locale to use when validating localized float values. Basic float validation By default, if no locale is provided, IsFloat will use the system locale. $validator = new Zend\\I18n\\Validator\\IsFloat(); $validator->isValid(1234.5); // returns true $validator->isValid('10a01'); // returns false $validator->isValid('1,234.5'); // returns true (The above example assumes that the environment locale is set to en .) Localized float validation Float values are often written differently based on the country or region. For example, using English, you might write 1.5 , whereas in german you would write 1,5 , and in other languages you might use grouping. Zend\\I18n\\Validator\\IsFloat is able to validate such notations. However, it is limited to the locale you set. See the following code: $validator = new Zend\\I18n\\Validator\\IsFloat(['locale' => 'de']); $validator->isValid(1234.5); // returns true $validator->isValid(\"1 234,5\"); // returns false $validator->isValid(\"1.234\"); // returns true By using a locale, your input is validated based on the locale provided. Using a notation not specific to the locale results in a false evaulation. The default validation locale can also be set after instantiation using setLocale() , and retrieved using getLocale() . Migration from 2.0-2.3 to 2.4+ Version 2.4 adds support for PHP 7. In PHP 7, float is a reserved keyword, which required renaming the Float validator. If you were using the Float validator directly previously, you will now receive an E_USER_DEPRECATED notice on instantiation. Please update your code to refer to the IsFloat class instead. Users pulling their Float validator instance from the validator plugin manager receive an IsFloat instance instead starting in 2.4.0. IsInt Zend\\I18n\\Validator\\IsInt validates if a given value is an integer, using the locale provided. Supported Options The following options are supported for Zend\\I18n\\Validator\\IsInt : locale : Sets the locale to use when validating localized integers. strict : Sets whether or not the value's data type should be checked. Basic integer validation When no locale is provided to the validator, it uses the system locale: $validator = new Zend\\I18n\\Validator\\IsInt(); $validator->isValid(1234); // returns true $validator->isValid(1234.5); // returns false $validator->isValid('1,234'); // returns true (The above example assumes that the environment locale is set to en .) Strict validation By default, the value's data type is not enforced. $validator = new Zend\\I18n\\Validator\\IsInt(); $validator->isValid(1234); // returns true $validator->isValid('1234'); // returns true $validator = new Zend\\I18n\\Validator\\IsInt(); $validator->setStrict(true); $validator->isValid(1234); // returns true $validator->isValid('1234'); // returns false Localized integer validation Integer values are often written differently based on country or region. For example, using English, you may write \"1234\" or \"1,234\"; both are integer values, but the grouping is optional. In German, you'd write \"1.234\", and in French, \"1 234\". Zend\\I18n\\Validator\\IsInt will use a provided locale when evaluating the validity of an integer value. In such cases, it doesn't simply strip the validator, but instead validates that the correct separator as defined by the locale is used. $validator = new Zend\\I18n\\Validator\\IsInt(['locale' => 'de']); $validator->isValid(1234); // returns true $validator->isValid(\"1,234\"); // returns false $validator->isValid(\"1.234\"); // returns true By using a locale, your input is validated based on the locale provided. Using a notation not specific to the locale results in a false evaulation. The default validation locale can also be set after instantiation using setLocale() , and retrieved using getLocale() . Migration from 2.0-2.3 to 2.4+ Version 2.4 adds support for PHP 7. In PHP 7, int is a reserved keyword, which required renaming the Int validator. If you were using the Int validator directly previously, you will now receive an E_USER_DEPRECATED notice on instantiation. Please update your code to refer to the IsInt class instead. Users pulling their Int validator instance from the validator plugin manager receive an IsInt instance instead starting in 2.4.0. PostCode Zend\\I18n\\Validator\\PostCode allows you to determine if a given value is a valid postal code. Postal codes are specific to cities, and in some locales termed ZIP codes. Zend\\I18n\\Validator\\PostCode knows more than 160 different postal code formats. To select the correct format there are two ways. You can either use a fully qualified locale, or you can set your own format manually. Supported options The following options are supported for Zend\\I18n\\Validator\\PostCode : format : Sets a postcode format which will be used for validation of the input. locale : Sets a locale from which the postcode will be taken from. Usage Using a locale is more convenient as zend-validator already knows the appropriate postal code format for each locale; however, you need to use the fully qualified locale (one containing a region specifier) to do so. For instance, the locale de is a locale but could not be used with Zend\\I18n\\Validator\\PostCode as it does not include the region; de_AT , however, would be a valid locale, as it specifies the region code ( AT , for Austria). $validator = new Zend\\I18n\\Validator\\PostCode('de_AT'); When you don't set a locale yourself, then Zend\\I18n\\Validator\\PostCode will use the application wide set locale, or, when there is none, the locale returned by Locale . // application wide locale within your bootstrap Locale::setDefault('de_AT'); $validator = new Zend\\I18n\\Validator\\PostCode(); You can also change the locale afterwards by calling setLocale() . And of course you can get the actual used locale by calling getLocale() . $validator = new Zend\\I18n\\Validator\\PostCode('de_AT'); $validator->setLocale('en_GB'); Postal code formats are regular expression strings. When the international postal code format, which is used by setting the locale, does not fit your needs, then you can also manually set a format by calling setFormat() . $validator = new Zend\\I18n\\Validator\\PostCode('de_AT'); $validator->setFormat('AT-\\d{5}'); Conventions for self defined formats When using self defined formats, you should omit the regex delimiters and anchors ( '/^' and '$/' ). They are attached automatically. You should also be aware that postcode values will always be validated in a strict way. This means that they have to be written standalone without additional characters when they are not covered by the format. Constructor options At its most basic, you may pass a string representing a fully qualified locale to the constructor of Zend\\I18n\\Validator\\PostCode . $validator = new Zend\\I18n\\Validator\\PostCode('de_AT'); Additionally, you may pass either an array or a Traversable instance to the constructor. When you do so, you must include either the key locale or format ; these will be used to set the appropriate values in the validator object. $validator = new Zend\\I18n\\Validator\\PostCode([ 'locale' => 'de_AT', 'format' => 'AT_\\d+' ]);","title":"Validators"},{"location":"validators/#validators","text":"zend-i18n provides a set of validators that use internationalization capabilities.","title":"Validators"},{"location":"validators/#alnum","text":"Zend\\I18n\\Validator\\Alnum allows you to validate if a given value contains only alphabetical characters and digits. There is no length limitation for the input you want to validate.","title":"Alnum"},{"location":"validators/#supported-options","text":"The following options are supported for Zend\\I18n\\Validator\\Alnum : allowWhiteSpace : Whether or not whitespace characters are allowed. This option defaults to FALSE .","title":"Supported options"},{"location":"validators/#basic-usage","text":"$validator = new Zend\\I18n\\Validator\\Alnum(); if ($validator->isValid('Abcd12')) { // value contains only allowed chars } else { // false }","title":"Basic usage"},{"location":"validators/#using-whitespace","text":"By default, whitespace is not accepted as it is not part of the alphabet. However, if you want to validate complete sentences or phrases, you may need to allow whitespace; this can be done via the allowWhiteSpace option, either at instantiation or afterwards via the setAllowWhiteSpace() method. To get the current state of the flag, use the getAllowWhiteSpace() method. $validator = new Zend\\I18n\\Validator\\Alnum(['allowWhiteSpace' => true]); // or set it via method call: $validator->setAllowWhiteSpace(true); if ($validator->isValid('Abcd and 12')) { // value contains only allowed chars } else { // false }","title":"Using whitespace"},{"location":"validators/#using-different-languages","text":"Several languages supported by ext/intl use alphabets where characters are formed from multiple bytes, including Korean , Japanese , and Chinese . Such languages therefore are unsupported with regards to the Alnum validator. When using the Alnum validator with these languages, the input will be validated using the English alphabet.","title":"Using different languages"},{"location":"validators/#alpha","text":"Zend\\I18n\\Validator\\Alpha allows you to validate if a given value contains only alphabetical characters. There is no length limitation for the input you want to validate. This validator is identical to the Zend\\I18n\\Validator\\Alnum validator with the exception that it does not accept digits.","title":"Alpha"},{"location":"validators/#supported-options_1","text":"The following options are supported for Zend\\I18n\\Validator\\Alpha : allowWhiteSpace : Whether or not whitespace characters are allowed. This option defaults to FALSE .","title":"Supported options"},{"location":"validators/#basic-usage_1","text":"$validator = new Zend\\I18n\\Validator\\Alpha(); if ($validator->isValid('Abcd')) { // value contains only allowed chars } else { // false }","title":"Basic usage"},{"location":"validators/#using-whitespace_1","text":"By default, whitespace is not accepted as it is not part of the alphabet. However, if you want to validate complete sentences or phrases, you may need to allow whitespace; this can be done via the allowWhiteSpace option, either at instantiation or afterwards via the setAllowWhiteSpace() method. To get the current state of the flag, use the getAllowWhiteSpace() method. $validator = new Zend\\I18n\\Validator\\Alpha(['allowWhiteSpace' => true]); // or set it via method call: $validator->setAllowWhiteSpace(true); if ($validator->isValid('Abcd and efg')) { // value contains only allowed chars } else { // false }","title":"Using whitespace"},{"location":"validators/#using-different-languages_1","text":"When using Zend\\I18n\\Validator\\Alpha , the language provided by the user's browser will be used to set the allowed characters. For locales outside of English, this means that additional alphabetic characters may be used \u2014 such as \u00e4 , \u00f6 and \u00fc from the German alphabet. Which characters are allowed depends completely on the language, as every language defines its own set of characters. Three languages supported by ext/intl, however, define multibyte characters, which cannot be matched as alphabetic characters using normal string or regular expression options. These include Korean , Japanese , and Chinese . As a result, when using the Alpha validator with these languages, the input will be validated using the English alphabet.","title":"Using different languages"},{"location":"validators/#isfloat","text":"Zend\\I18n\\Validator\\IsFloat allows you to validate if a given value contains a floating-point value. This validator takes into account localized input.","title":"IsFloat"},{"location":"validators/#supported-options_2","text":"The following options are supported for Zend\\I18n\\Validator\\IsFloat : locale : Sets the locale to use when validating localized float values.","title":"Supported options"},{"location":"validators/#basic-float-validation","text":"By default, if no locale is provided, IsFloat will use the system locale. $validator = new Zend\\I18n\\Validator\\IsFloat(); $validator->isValid(1234.5); // returns true $validator->isValid('10a01'); // returns false $validator->isValid('1,234.5'); // returns true (The above example assumes that the environment locale is set to en .)","title":"Basic float validation"},{"location":"validators/#localized-float-validation","text":"Float values are often written differently based on the country or region. For example, using English, you might write 1.5 , whereas in german you would write 1,5 , and in other languages you might use grouping. Zend\\I18n\\Validator\\IsFloat is able to validate such notations. However, it is limited to the locale you set. See the following code: $validator = new Zend\\I18n\\Validator\\IsFloat(['locale' => 'de']); $validator->isValid(1234.5); // returns true $validator->isValid(\"1 234,5\"); // returns false $validator->isValid(\"1.234\"); // returns true By using a locale, your input is validated based on the locale provided. Using a notation not specific to the locale results in a false evaulation. The default validation locale can also be set after instantiation using setLocale() , and retrieved using getLocale() .","title":"Localized float validation"},{"location":"validators/#migration-from-20-23-to-24","text":"Version 2.4 adds support for PHP 7. In PHP 7, float is a reserved keyword, which required renaming the Float validator. If you were using the Float validator directly previously, you will now receive an E_USER_DEPRECATED notice on instantiation. Please update your code to refer to the IsFloat class instead. Users pulling their Float validator instance from the validator plugin manager receive an IsFloat instance instead starting in 2.4.0.","title":"Migration from 2.0-2.3 to 2.4+"},{"location":"validators/#isint","text":"Zend\\I18n\\Validator\\IsInt validates if a given value is an integer, using the locale provided.","title":"IsInt"},{"location":"validators/#supported-options_3","text":"The following options are supported for Zend\\I18n\\Validator\\IsInt : locale : Sets the locale to use when validating localized integers. strict : Sets whether or not the value's data type should be checked.","title":"Supported Options"},{"location":"validators/#basic-integer-validation","text":"When no locale is provided to the validator, it uses the system locale: $validator = new Zend\\I18n\\Validator\\IsInt(); $validator->isValid(1234); // returns true $validator->isValid(1234.5); // returns false $validator->isValid('1,234'); // returns true (The above example assumes that the environment locale is set to en .)","title":"Basic integer validation"},{"location":"validators/#strict-validation","text":"By default, the value's data type is not enforced. $validator = new Zend\\I18n\\Validator\\IsInt(); $validator->isValid(1234); // returns true $validator->isValid('1234'); // returns true $validator = new Zend\\I18n\\Validator\\IsInt(); $validator->setStrict(true); $validator->isValid(1234); // returns true $validator->isValid('1234'); // returns false","title":"Strict validation"},{"location":"validators/#localized-integer-validation","text":"Integer values are often written differently based on country or region. For example, using English, you may write \"1234\" or \"1,234\"; both are integer values, but the grouping is optional. In German, you'd write \"1.234\", and in French, \"1 234\". Zend\\I18n\\Validator\\IsInt will use a provided locale when evaluating the validity of an integer value. In such cases, it doesn't simply strip the validator, but instead validates that the correct separator as defined by the locale is used. $validator = new Zend\\I18n\\Validator\\IsInt(['locale' => 'de']); $validator->isValid(1234); // returns true $validator->isValid(\"1,234\"); // returns false $validator->isValid(\"1.234\"); // returns true By using a locale, your input is validated based on the locale provided. Using a notation not specific to the locale results in a false evaulation. The default validation locale can also be set after instantiation using setLocale() , and retrieved using getLocale() .","title":"Localized integer validation"},{"location":"validators/#migration-from-20-23-to-24_1","text":"Version 2.4 adds support for PHP 7. In PHP 7, int is a reserved keyword, which required renaming the Int validator. If you were using the Int validator directly previously, you will now receive an E_USER_DEPRECATED notice on instantiation. Please update your code to refer to the IsInt class instead. Users pulling their Int validator instance from the validator plugin manager receive an IsInt instance instead starting in 2.4.0.","title":"Migration from 2.0-2.3 to 2.4+"},{"location":"validators/#postcode","text":"Zend\\I18n\\Validator\\PostCode allows you to determine if a given value is a valid postal code. Postal codes are specific to cities, and in some locales termed ZIP codes. Zend\\I18n\\Validator\\PostCode knows more than 160 different postal code formats. To select the correct format there are two ways. You can either use a fully qualified locale, or you can set your own format manually.","title":"PostCode"},{"location":"validators/#supported-options_4","text":"The following options are supported for Zend\\I18n\\Validator\\PostCode : format : Sets a postcode format which will be used for validation of the input. locale : Sets a locale from which the postcode will be taken from.","title":"Supported options"},{"location":"validators/#usage","text":"Using a locale is more convenient as zend-validator already knows the appropriate postal code format for each locale; however, you need to use the fully qualified locale (one containing a region specifier) to do so. For instance, the locale de is a locale but could not be used with Zend\\I18n\\Validator\\PostCode as it does not include the region; de_AT , however, would be a valid locale, as it specifies the region code ( AT , for Austria). $validator = new Zend\\I18n\\Validator\\PostCode('de_AT'); When you don't set a locale yourself, then Zend\\I18n\\Validator\\PostCode will use the application wide set locale, or, when there is none, the locale returned by Locale . // application wide locale within your bootstrap Locale::setDefault('de_AT'); $validator = new Zend\\I18n\\Validator\\PostCode(); You can also change the locale afterwards by calling setLocale() . And of course you can get the actual used locale by calling getLocale() . $validator = new Zend\\I18n\\Validator\\PostCode('de_AT'); $validator->setLocale('en_GB'); Postal code formats are regular expression strings. When the international postal code format, which is used by setting the locale, does not fit your needs, then you can also manually set a format by calling setFormat() . $validator = new Zend\\I18n\\Validator\\PostCode('de_AT'); $validator->setFormat('AT-\\d{5}');","title":"Usage"},{"location":"validators/#conventions-for-self-defined-formats","text":"When using self defined formats, you should omit the regex delimiters and anchors ( '/^' and '$/' ). They are attached automatically. You should also be aware that postcode values will always be validated in a strict way. This means that they have to be written standalone without additional characters when they are not covered by the format.","title":"Conventions for self defined formats"},{"location":"validators/#constructor-options","text":"At its most basic, you may pass a string representing a fully qualified locale to the constructor of Zend\\I18n\\Validator\\PostCode . $validator = new Zend\\I18n\\Validator\\PostCode('de_AT'); Additionally, you may pass either an array or a Traversable instance to the constructor. When you do so, you must include either the key locale or format ; these will be used to set the appropriate values in the validator object. $validator = new Zend\\I18n\\Validator\\PostCode([ 'locale' => 'de_AT', 'format' => 'AT_\\d+' ]);","title":"Constructor options"},{"location":"view-helpers/","text":"View Helpers zend-i18n ships with a set of zend-view helper classes related to internationalization: e.g., formatting a date, formatting currency, or displaying translated content. See the zend-view helpers documentation for more information. CurrencyFormat Helper The CurrencyFormat view helper can be used to simplify rendering of localized currency values. It acts as a wrapper for the NumberFormatter class within the internationalization extension (ext/intl). Basic Usage // Within your view: echo $this->currencyFormat(1234.56, 'USD', null, 'en_US'); // Returns: \"$1,234.56\" echo $this->currencyFormat(1234.56, 'EUR', null, 'de_DE'); // Returns: \"1.234,56 \u20ac\" echo $this->currencyFormat(1234.56, 'USD', true, 'en_US'); // Returns: \"$1,234.56\" echo $this->currencyFormat(1234.56, 'USD', false, 'en_US'); // Returns: \"$1,235\" echo $this->currencyFormat(12345678.90, 'EUR', true, 'de_DE', '#0.# kg'); // Returns: \"12345678,90 kg\" echo $this->currencyFormat(12345678.90, 'EUR', false, 'de_DE', '#0.# kg'); // Returns: \"12345679 kg\" Method description currencyFormat( float $number [, string $currencyCode = null [, bool $showDecimals = null [, string $locale = null [, string $pattern = null ] ] ] ]) : string where: $number : the numeric currency value. $currencyCode : the 3-letter ISO 4217 currency code indicating the currency to use. If unset, it will use the default value current in the helper instance ( null by default). $showDecimals : Boolean false indicates that no decimals should be represented. If unset, it will use the value current in the helper instance ( true by default). $locale : Locale in which the currency would be formatted (locale name, e.g. en_US ). If unset, it will use the default locale (default is the value of Locale::getDefault() ). $pattern : Pattern string the formatter should use. If unset, it will use the value current in the helper instance ( null by default). Available Functionality Set the currency code and the locale The $currencyCode and $locale options can be set prior to formatting and will be applied each time the helper is used: // Within your view $this->plugin('currencyformat')->setCurrencyCode('USD')->setLocale('en_US'); echo $this->currencyFormat(1234.56); // This returns: \"$1,234.56\" echo $this->currencyFormat(5678.90); // This returns: \"$5,678.90\" The method signatures are: setCurrencyCode(string $currencyCode) : CurrencyFormat where $currencyCode is the 3-letter ISO 4217 currency code, and setLocale(string $locale) : CurrencyFormat where $locale is the locale with which to format the number. Show decimals // Within your view $this->plugin('currencyformat')->setShouldShowDecimals(false); echo $this->currencyFormat(1234.56, 'USD', null, 'en_US'); // This returns: \"$1,235\" with the following method signature: setShouldShowDecimals(bool $showDecimals) : CurrencyFormat where $showDecimals indicates whether or not decimal values will be displayed. Set the currency pattern // Within your view $this->plugin('currencyformat')->setCurrencyPattern('#0.# kg'); echo $this->currencyFormat(12345678.90, 'EUR', null, 'de_DE'); // This returns: \"12345678,90 kg\" with the following method signature: setCurrencyPattern(string $currencyPattern) : CurrencyFormat where $currencyPattern is a valid ICU DecimalFormat pattern ; see the NumberFormatter::setPattern() documentation for more information. DateFormat Helper The DateFormat view helper can be used to simplify rendering of localized date/time values. It acts as a wrapper for the IntlDateFormatter class within ext/intl. Basic Usage // Within your view // Date and Time echo $this->dateFormat( new DateTime(), IntlDateFormatter::MEDIUM, // date IntlDateFormatter::MEDIUM, // time \"en_US\" ); // This returns: \"Jul 2, 2012 6:44:03 PM\" // Date Only echo $this->dateFormat( new DateTime(), IntlDateFormatter::LONG, // date IntlDateFormatter::NONE, // time \"en_US\" ); // This returns: \"July 2, 2012\" // Time Only echo $this->dateFormat( new DateTime(), IntlDateFormatter::NONE, // date IntlDateFormatter::SHORT, // time \"en_US\" ); // This returns: \"6:44 PM\" Method description dateFormat( mixed $date [, int $dateType = null [, int $timeType = null [, string $locale = null ] ] ]) : string where: $date : The value to format. This may be a DateTime instance, an integer representing a Unix timestamp value, or an array in the format returned by localtime() . $dateType : Date type to use (none, short, medium, long, full). This is one of the IntlDateFormatter constants . Defaults to IntlDateFormatter::NONE . $timeType : Time type to use (none, short, medium, long, full). This is one of the IntlDateFormatter constants . Defaults to IntlDateFormatter::NONE . $locale : Locale in which the date would be formatted (locale name, e.g. en_US ). If unset, it will use the default locale (return value of Locale::getDefault() ). Public Methods The $locale option can be set prior to formatting with the setLocale() method and will be applied each time the helper is used. By default, the system's default timezone will be used when formatting. This overrides any timezone that may be set inside a DateTime object. To change the timezone when formatting, use the setTimezone() method. // Within your view $this->plugin('dateFormat') ->setTimezone('America/New_York') ->setLocale('en_US'); echo $this->dateFormat(new DateTime(), IntlDateFormatter::MEDIUM); // \"Jul 2, 2012\" echo $this->dateFormat(new DateTime(), IntlDateFormatter::SHORT); // \"7/2/12\" NumberFormat Helper The NumberFormat view helper can be used to simplify rendering of locale-specific number and/or percentage strings. It acts as a wrapper for the NumberFormatter class within ext/intl. Basic Usage // Within your view // Example of Decimal formatting: echo $this->numberFormat( 1234567.891234567890000, NumberFormatter::DECIMAL, NumberFormatter::TYPE_DEFAULT, 'de_DE' ); // This returns: \"1.234.567,891\" // Example of Percent formatting: echo $this->numberFormat( 0.80, NumberFormatter::PERCENT, NumberFormatter::TYPE_DEFAULT, 'en_US' ); // This returns: \"80%\" // Example of Scientific notation formatting: echo $this->numberFormat( 0.00123456789, NumberFormatter::SCIENTIFIC, NumberFormatter::TYPE_DEFAULT, 'fr_FR' ); // This returns: \"1,23456789E-3\" Method description numberFormat( int|float $number [, int $formatStyle = null [, int $formatType = null [, string $locale = null [, int $decimals = null [, array $textAttributes = null ] ] ] ] ]) : string where: $number : the number to format. $formatStyle : one of the NumberFormatter styles: NumberFormatter::DECIMAL , NumberFormatter::CURRENCY , etc. $formatType : one of the NumberFormatter types: NumberFormatter::TYPE_DEFAULT (basic numeric), NumberFormatter::TYPE_CURRENCY , etc. $locale : a valid locale to use when formatting the number. $decimals : the number of digits beyond the decimal point to display. $textAttributes : text attributes to use with the number (e.g., prefix and/or suffix for positive/negative numbers, currency code): NumberFormatter::POSITIVE_PREFIX , NumberFormatter::NEGATIVE_PREFIX , etc. Public Methods Each of the $formatStyle , $formatType , $locale , and $textAttributes options can be set prior to formatting and will be applied each time the helper is used. // Within your view $this->plugin(\"numberformat\") ->setFormatStyle(NumberFormatter::PERCENT) ->setFormatType(NumberFormatter::TYPE_DOUBLE) ->setLocale(\"en_US\") ->setTextAttributes([ NumberFormatter::POSITIVE_PREFIX => '^ ', NumberFormatter::NEGATIVE_PREFIX => 'v ', ]); echo $this->numberFormat(0.56); // \"^ 56%\" echo $this->numberFormat(-0.90); // \"v 90%\" Plural Helper Most languages have specific rules for handling plurals. For instance, in English, we say \"0 cars\" and \"2 cars\" (plural) while we say \"1 car\" (singular). On the other hand, French uses the singular form for both 0 and 1 (\"0 voiture\" and \"1 voiture\") and the plural form otherwise (\"3 voitures\"). Therefore we often need to handle plural cases even without translation (mono-lingual application). The Plural helper was created for this. Plural helper does not translate If you need to handle both plural cases and translations, you must use the TranslatePlural helper; Plural does not translate. Internally, the Plural helper uses the Zend\\I18n\\Translator\\Plural\\Rule class to handle rules. Setup Defining plural rules is left to the developer. To help you with this process, here are some links with up-to-date plural rules for tons of languages: http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html https://developer.mozilla.org/en-US/docs/Localization_and_Plurals Basic Usage First, define a rule. As an example, you could add the following code in your Module class: // Get the ViewHelperPlugin Manager from the ServiceManager, so we can fetch the // Plural helper and add the plural rule for the application's language: $viewHelperManager = $serviceManager->get('ViewHelperManager'); $pluralHelper = $viewHelperManager->get('Plural'); // Here is the rule for French $pluralHelper->setPluralRule('nplurals=2; plural=(n==0 || n==1 ? 0 : 1)'); The string reads as follows: First, we specify how many plural forms we have. For French, only two (singular/plural). Next, we specify the rule. Here, if the count is 0 or 1, this is rule n\u00b00 (singular) while it's rule n\u00b01 otherwise. As noted earlier earlier, English considers \"1\" as singular and \"0/other\" as plural. Here is how that would be declared: // Here is the rule for English $pluralHelper->setPluralRule('nplurals=2; plural=(n==1 ? 0 : 1)'); Now that we have defined the rule, we can use it in our views: // Within a view script... // If the rule defined in Module.php is the English one: echo $this->plural(array('car', 'cars'), 0); // prints \"cars\" echo $this->plural(array('car', 'cars'), 1); // prints \"car\" // If the rule defined in Module.php is the French one: echo $this->plural(array('voiture', 'voitures'), 0); // prints \"voiture\" echo $this->plural(array('voiture', 'voitures'), 1); // prints \"voiture\" echo $this->plural(array('voiture', 'voitures'), 2); // prints \"voitures\" Translate Helper The Translate view helper can be used to translate content. It acts as a wrapper for the Zend\\I18n\\Translator\\Translator class. Setup Before using the Translate view helper, you must have first created a Translator object and have attached it to the view helper. If you use the Zend\\View\\HelperPluginManager to invoke the view helper, this will be done automatically for you. Basic Usage // Within your view... echo $this->translate(\"Some translated text.\"); echo $this->translate(\"Translated text from a custom text domain.\", \"customDomain\"); echo sprintf($this->translate(\"The current time is %s.\"), $currentTime); echo $this->translate(\"Translate in a specific locale\", \"default\", \"de_DE\"); Method description translate( string $message [, string $textDomain = null [, string $locale = null ] ]) : string where: $message : The message to translate. $textDomain : The text domain/context of the translation; defaults to \"default\". $locale : Locale to which the message should be translated (locale name, e.g. en_US ). If unset, it will use the default locale (return value of Locale::getDefault() ). Gettext The xgettext utility can be used to compile *.po files from PHP source files containing the translate view helper. $ xgettext --language=php --add-location --keyword=translate --keyword=translatePlural:1,2 my-view-file.phtml See the Gettext Wikipedia page for more information. Public Methods Public methods for setting a Zend\\I18n\\Translator\\Translator and a default text domain are inherited from the AbstractTranslatorHelper . TranslatePlural Helper The TranslatePlural view helper can be used to translate words which take into account numeric meanings. English, for example, has a singular definition of \"car\", for one car, and the plural definition, \"cars\", meaning zero \"cars\" or more than one car. Other languages like Russian or Polish have more plurals with different rules. The helper acts as a wrapper for the Zend\\I18n\\Translator\\Translator class. Setup Before using the TranslatePlural view helper, you must have first created a Translator object and have attached it to the view helper. If you use the Zend\\View\\HelperPluginManager to invoke the view helper, this will be done automatically for you. Basic Usage // Within your view echo $this->translatePlural(\"car\", \"cars\", $num); // Use a custom domain echo $this->translatePlural(\"monitor\", \"monitors\", $num, \"customDomain\"); // Change locale echo $this->translatePlural(\"locale\", \"locales\", $num, \"default\", \"de_DE\"); Method description translatePlural( string $singular, string $plural, int $number [, string $textDomain = null [, string $locale = null ] ]) : string where: $singular : The message to use for singular values. $plural : The message to use for plural values. $number : The number to evaluate in order to determine which number to use. $textDomain : The text domain/context of the translation; defaults to \"default\". $locale : Locale to which the message should be translated (locale name, e.g. en_US ). If unset, it will use the default locale (return value of Locale::getDefault() ). Gettext The xgettext utility can be used to compile *.po files from PHP source files containing the translate view helper. $ xgettext --language=php --add-location --keyword=translate --keyword=translatePlural:1,2 my-view-file.phtml See the Gettext Wikipedia page for more information. Public Methods Public methods for setting a Zend\\I18n\\Translator\\Translator and a default text domain are inherited from the AbstractTranslatorHelper . Abstract Translator Helper The AbstractTranslatorHelper view helper is used as a base abstract class for any helpers that need to translate content. It provides an implementation for the Zend\\I18n\\Translator\\TranslatorAwareInterface , allowing translator injection as well as text domain injection. Public Methods setTranslator() setTranslator( Translator $translator [ , string $textDomain = null ] ) : void Sets the Zend\\I18n\\Translator\\Translator instance to use in the helper. The $textDomain argument is optional, and provided as a convenienct to allow setting both the translator and text domain simultaneously. getTranslator() getTranslator() : Translator Returns the Zend\\I18n\\Translator\\Translator instance used by the helper. hasTranslator() hasTranslator() : bool Returns true if the helper composes a Zend\\I18n\\Translator\\Translator instance. setTranslatorEnabled() setTranslatorEnabled(bool $enabled) : void Sets whether or not translations are enabled. isTranslatorEnabled() isTranslatorEnabled() : bool Returns true if translations are enabled. setTranslatorTextDomain() setTranslatorTextDomain(string $textDomain) : void Sets the default translation text domain to use with the helper. getTranslatorTextDomain() getTranslatorTextDomain() : string Returns the current text domain used by the helper.","title":"View Helpers"},{"location":"view-helpers/#view-helpers","text":"zend-i18n ships with a set of zend-view helper classes related to internationalization: e.g., formatting a date, formatting currency, or displaying translated content. See the zend-view helpers documentation for more information.","title":"View Helpers"},{"location":"view-helpers/#currencyformat-helper","text":"The CurrencyFormat view helper can be used to simplify rendering of localized currency values. It acts as a wrapper for the NumberFormatter class within the internationalization extension (ext/intl).","title":"CurrencyFormat Helper"},{"location":"view-helpers/#basic-usage","text":"// Within your view: echo $this->currencyFormat(1234.56, 'USD', null, 'en_US'); // Returns: \"$1,234.56\" echo $this->currencyFormat(1234.56, 'EUR', null, 'de_DE'); // Returns: \"1.234,56 \u20ac\" echo $this->currencyFormat(1234.56, 'USD', true, 'en_US'); // Returns: \"$1,234.56\" echo $this->currencyFormat(1234.56, 'USD', false, 'en_US'); // Returns: \"$1,235\" echo $this->currencyFormat(12345678.90, 'EUR', true, 'de_DE', '#0.# kg'); // Returns: \"12345678,90 kg\" echo $this->currencyFormat(12345678.90, 'EUR', false, 'de_DE', '#0.# kg'); // Returns: \"12345679 kg\"","title":"Basic Usage"},{"location":"view-helpers/#method-description","text":"currencyFormat( float $number [, string $currencyCode = null [, bool $showDecimals = null [, string $locale = null [, string $pattern = null ] ] ] ]) : string where: $number : the numeric currency value. $currencyCode : the 3-letter ISO 4217 currency code indicating the currency to use. If unset, it will use the default value current in the helper instance ( null by default). $showDecimals : Boolean false indicates that no decimals should be represented. If unset, it will use the value current in the helper instance ( true by default). $locale : Locale in which the currency would be formatted (locale name, e.g. en_US ). If unset, it will use the default locale (default is the value of Locale::getDefault() ). $pattern : Pattern string the formatter should use. If unset, it will use the value current in the helper instance ( null by default).","title":"Method description"},{"location":"view-helpers/#available-functionality","text":"","title":"Available Functionality"},{"location":"view-helpers/#set-the-currency-code-and-the-locale","text":"The $currencyCode and $locale options can be set prior to formatting and will be applied each time the helper is used: // Within your view $this->plugin('currencyformat')->setCurrencyCode('USD')->setLocale('en_US'); echo $this->currencyFormat(1234.56); // This returns: \"$1,234.56\" echo $this->currencyFormat(5678.90); // This returns: \"$5,678.90\" The method signatures are: setCurrencyCode(string $currencyCode) : CurrencyFormat where $currencyCode is the 3-letter ISO 4217 currency code, and setLocale(string $locale) : CurrencyFormat where $locale is the locale with which to format the number.","title":"Set the currency code and the locale"},{"location":"view-helpers/#show-decimals","text":"// Within your view $this->plugin('currencyformat')->setShouldShowDecimals(false); echo $this->currencyFormat(1234.56, 'USD', null, 'en_US'); // This returns: \"$1,235\" with the following method signature: setShouldShowDecimals(bool $showDecimals) : CurrencyFormat where $showDecimals indicates whether or not decimal values will be displayed.","title":"Show decimals"},{"location":"view-helpers/#set-the-currency-pattern","text":"// Within your view $this->plugin('currencyformat')->setCurrencyPattern('#0.# kg'); echo $this->currencyFormat(12345678.90, 'EUR', null, 'de_DE'); // This returns: \"12345678,90 kg\" with the following method signature: setCurrencyPattern(string $currencyPattern) : CurrencyFormat where $currencyPattern is a valid ICU DecimalFormat pattern ; see the NumberFormatter::setPattern() documentation for more information.","title":"Set the currency pattern"},{"location":"view-helpers/#dateformat-helper","text":"The DateFormat view helper can be used to simplify rendering of localized date/time values. It acts as a wrapper for the IntlDateFormatter class within ext/intl.","title":"DateFormat Helper"},{"location":"view-helpers/#basic-usage_1","text":"// Within your view // Date and Time echo $this->dateFormat( new DateTime(), IntlDateFormatter::MEDIUM, // date IntlDateFormatter::MEDIUM, // time \"en_US\" ); // This returns: \"Jul 2, 2012 6:44:03 PM\" // Date Only echo $this->dateFormat( new DateTime(), IntlDateFormatter::LONG, // date IntlDateFormatter::NONE, // time \"en_US\" ); // This returns: \"July 2, 2012\" // Time Only echo $this->dateFormat( new DateTime(), IntlDateFormatter::NONE, // date IntlDateFormatter::SHORT, // time \"en_US\" ); // This returns: \"6:44 PM\"","title":"Basic Usage"},{"location":"view-helpers/#method-description_1","text":"dateFormat( mixed $date [, int $dateType = null [, int $timeType = null [, string $locale = null ] ] ]) : string where: $date : The value to format. This may be a DateTime instance, an integer representing a Unix timestamp value, or an array in the format returned by localtime() . $dateType : Date type to use (none, short, medium, long, full). This is one of the IntlDateFormatter constants . Defaults to IntlDateFormatter::NONE . $timeType : Time type to use (none, short, medium, long, full). This is one of the IntlDateFormatter constants . Defaults to IntlDateFormatter::NONE . $locale : Locale in which the date would be formatted (locale name, e.g. en_US ). If unset, it will use the default locale (return value of Locale::getDefault() ).","title":"Method description"},{"location":"view-helpers/#public-methods","text":"The $locale option can be set prior to formatting with the setLocale() method and will be applied each time the helper is used. By default, the system's default timezone will be used when formatting. This overrides any timezone that may be set inside a DateTime object. To change the timezone when formatting, use the setTimezone() method. // Within your view $this->plugin('dateFormat') ->setTimezone('America/New_York') ->setLocale('en_US'); echo $this->dateFormat(new DateTime(), IntlDateFormatter::MEDIUM); // \"Jul 2, 2012\" echo $this->dateFormat(new DateTime(), IntlDateFormatter::SHORT); // \"7/2/12\"","title":"Public Methods"},{"location":"view-helpers/#numberformat-helper","text":"The NumberFormat view helper can be used to simplify rendering of locale-specific number and/or percentage strings. It acts as a wrapper for the NumberFormatter class within ext/intl.","title":"NumberFormat Helper"},{"location":"view-helpers/#basic-usage_2","text":"// Within your view // Example of Decimal formatting: echo $this->numberFormat( 1234567.891234567890000, NumberFormatter::DECIMAL, NumberFormatter::TYPE_DEFAULT, 'de_DE' ); // This returns: \"1.234.567,891\" // Example of Percent formatting: echo $this->numberFormat( 0.80, NumberFormatter::PERCENT, NumberFormatter::TYPE_DEFAULT, 'en_US' ); // This returns: \"80%\" // Example of Scientific notation formatting: echo $this->numberFormat( 0.00123456789, NumberFormatter::SCIENTIFIC, NumberFormatter::TYPE_DEFAULT, 'fr_FR' ); // This returns: \"1,23456789E-3\"","title":"Basic Usage"},{"location":"view-helpers/#method-description_2","text":"numberFormat( int|float $number [, int $formatStyle = null [, int $formatType = null [, string $locale = null [, int $decimals = null [, array $textAttributes = null ] ] ] ] ]) : string where: $number : the number to format. $formatStyle : one of the NumberFormatter styles: NumberFormatter::DECIMAL , NumberFormatter::CURRENCY , etc. $formatType : one of the NumberFormatter types: NumberFormatter::TYPE_DEFAULT (basic numeric), NumberFormatter::TYPE_CURRENCY , etc. $locale : a valid locale to use when formatting the number. $decimals : the number of digits beyond the decimal point to display. $textAttributes : text attributes to use with the number (e.g., prefix and/or suffix for positive/negative numbers, currency code): NumberFormatter::POSITIVE_PREFIX , NumberFormatter::NEGATIVE_PREFIX , etc.","title":"Method description"},{"location":"view-helpers/#public-methods_1","text":"Each of the $formatStyle , $formatType , $locale , and $textAttributes options can be set prior to formatting and will be applied each time the helper is used. // Within your view $this->plugin(\"numberformat\") ->setFormatStyle(NumberFormatter::PERCENT) ->setFormatType(NumberFormatter::TYPE_DOUBLE) ->setLocale(\"en_US\") ->setTextAttributes([ NumberFormatter::POSITIVE_PREFIX => '^ ', NumberFormatter::NEGATIVE_PREFIX => 'v ', ]); echo $this->numberFormat(0.56); // \"^ 56%\" echo $this->numberFormat(-0.90); // \"v 90%\"","title":"Public Methods"},{"location":"view-helpers/#plural-helper","text":"Most languages have specific rules for handling plurals. For instance, in English, we say \"0 cars\" and \"2 cars\" (plural) while we say \"1 car\" (singular). On the other hand, French uses the singular form for both 0 and 1 (\"0 voiture\" and \"1 voiture\") and the plural form otherwise (\"3 voitures\"). Therefore we often need to handle plural cases even without translation (mono-lingual application). The Plural helper was created for this.","title":"Plural Helper"},{"location":"view-helpers/#plural-helper-does-not-translate","text":"If you need to handle both plural cases and translations, you must use the TranslatePlural helper; Plural does not translate. Internally, the Plural helper uses the Zend\\I18n\\Translator\\Plural\\Rule class to handle rules.","title":"Plural helper does not translate"},{"location":"view-helpers/#setup","text":"Defining plural rules is left to the developer. To help you with this process, here are some links with up-to-date plural rules for tons of languages: http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html https://developer.mozilla.org/en-US/docs/Localization_and_Plurals","title":"Setup"},{"location":"view-helpers/#basic-usage_3","text":"First, define a rule. As an example, you could add the following code in your Module class: // Get the ViewHelperPlugin Manager from the ServiceManager, so we can fetch the // Plural helper and add the plural rule for the application's language: $viewHelperManager = $serviceManager->get('ViewHelperManager'); $pluralHelper = $viewHelperManager->get('Plural'); // Here is the rule for French $pluralHelper->setPluralRule('nplurals=2; plural=(n==0 || n==1 ? 0 : 1)'); The string reads as follows: First, we specify how many plural forms we have. For French, only two (singular/plural). Next, we specify the rule. Here, if the count is 0 or 1, this is rule n\u00b00 (singular) while it's rule n\u00b01 otherwise. As noted earlier earlier, English considers \"1\" as singular and \"0/other\" as plural. Here is how that would be declared: // Here is the rule for English $pluralHelper->setPluralRule('nplurals=2; plural=(n==1 ? 0 : 1)'); Now that we have defined the rule, we can use it in our views: // Within a view script... // If the rule defined in Module.php is the English one: echo $this->plural(array('car', 'cars'), 0); // prints \"cars\" echo $this->plural(array('car', 'cars'), 1); // prints \"car\" // If the rule defined in Module.php is the French one: echo $this->plural(array('voiture', 'voitures'), 0); // prints \"voiture\" echo $this->plural(array('voiture', 'voitures'), 1); // prints \"voiture\" echo $this->plural(array('voiture', 'voitures'), 2); // prints \"voitures\"","title":"Basic Usage"},{"location":"view-helpers/#translate-helper","text":"The Translate view helper can be used to translate content. It acts as a wrapper for the Zend\\I18n\\Translator\\Translator class.","title":"Translate Helper"},{"location":"view-helpers/#setup_1","text":"Before using the Translate view helper, you must have first created a Translator object and have attached it to the view helper. If you use the Zend\\View\\HelperPluginManager to invoke the view helper, this will be done automatically for you.","title":"Setup"},{"location":"view-helpers/#basic-usage_4","text":"// Within your view... echo $this->translate(\"Some translated text.\"); echo $this->translate(\"Translated text from a custom text domain.\", \"customDomain\"); echo sprintf($this->translate(\"The current time is %s.\"), $currentTime); echo $this->translate(\"Translate in a specific locale\", \"default\", \"de_DE\");","title":"Basic Usage"},{"location":"view-helpers/#method-description_3","text":"translate( string $message [, string $textDomain = null [, string $locale = null ] ]) : string where: $message : The message to translate. $textDomain : The text domain/context of the translation; defaults to \"default\". $locale : Locale to which the message should be translated (locale name, e.g. en_US ). If unset, it will use the default locale (return value of Locale::getDefault() ).","title":"Method description"},{"location":"view-helpers/#gettext","text":"The xgettext utility can be used to compile *.po files from PHP source files containing the translate view helper. $ xgettext --language=php --add-location --keyword=translate --keyword=translatePlural:1,2 my-view-file.phtml See the Gettext Wikipedia page for more information.","title":"Gettext"},{"location":"view-helpers/#public-methods_2","text":"Public methods for setting a Zend\\I18n\\Translator\\Translator and a default text domain are inherited from the AbstractTranslatorHelper .","title":"Public Methods"},{"location":"view-helpers/#translateplural-helper","text":"The TranslatePlural view helper can be used to translate words which take into account numeric meanings. English, for example, has a singular definition of \"car\", for one car, and the plural definition, \"cars\", meaning zero \"cars\" or more than one car. Other languages like Russian or Polish have more plurals with different rules. The helper acts as a wrapper for the Zend\\I18n\\Translator\\Translator class.","title":"TranslatePlural Helper"},{"location":"view-helpers/#setup_2","text":"Before using the TranslatePlural view helper, you must have first created a Translator object and have attached it to the view helper. If you use the Zend\\View\\HelperPluginManager to invoke the view helper, this will be done automatically for you.","title":"Setup"},{"location":"view-helpers/#basic-usage_5","text":"// Within your view echo $this->translatePlural(\"car\", \"cars\", $num); // Use a custom domain echo $this->translatePlural(\"monitor\", \"monitors\", $num, \"customDomain\"); // Change locale echo $this->translatePlural(\"locale\", \"locales\", $num, \"default\", \"de_DE\");","title":"Basic Usage"},{"location":"view-helpers/#method-description_4","text":"translatePlural( string $singular, string $plural, int $number [, string $textDomain = null [, string $locale = null ] ]) : string where: $singular : The message to use for singular values. $plural : The message to use for plural values. $number : The number to evaluate in order to determine which number to use. $textDomain : The text domain/context of the translation; defaults to \"default\". $locale : Locale to which the message should be translated (locale name, e.g. en_US ). If unset, it will use the default locale (return value of Locale::getDefault() ).","title":"Method description"},{"location":"view-helpers/#gettext_1","text":"The xgettext utility can be used to compile *.po files from PHP source files containing the translate view helper. $ xgettext --language=php --add-location --keyword=translate --keyword=translatePlural:1,2 my-view-file.phtml See the Gettext Wikipedia page for more information.","title":"Gettext"},{"location":"view-helpers/#public-methods_3","text":"Public methods for setting a Zend\\I18n\\Translator\\Translator and a default text domain are inherited from the AbstractTranslatorHelper .","title":"Public Methods"},{"location":"view-helpers/#abstract-translator-helper","text":"The AbstractTranslatorHelper view helper is used as a base abstract class for any helpers that need to translate content. It provides an implementation for the Zend\\I18n\\Translator\\TranslatorAwareInterface , allowing translator injection as well as text domain injection.","title":"Abstract Translator Helper"},{"location":"view-helpers/#public-methods_4","text":"","title":"Public Methods"},{"location":"view-helpers/#settranslator","text":"setTranslator( Translator $translator [ , string $textDomain = null ] ) : void Sets the Zend\\I18n\\Translator\\Translator instance to use in the helper. The $textDomain argument is optional, and provided as a convenienct to allow setting both the translator and text domain simultaneously.","title":"setTranslator()"},{"location":"view-helpers/#gettranslator","text":"getTranslator() : Translator Returns the Zend\\I18n\\Translator\\Translator instance used by the helper.","title":"getTranslator()"},{"location":"view-helpers/#hastranslator","text":"hasTranslator() : bool Returns true if the helper composes a Zend\\I18n\\Translator\\Translator instance.","title":"hasTranslator()"},{"location":"view-helpers/#settranslatorenabled","text":"setTranslatorEnabled(bool $enabled) : void Sets whether or not translations are enabled.","title":"setTranslatorEnabled()"},{"location":"view-helpers/#istranslatorenabled","text":"isTranslatorEnabled() : bool Returns true if translations are enabled.","title":"isTranslatorEnabled()"},{"location":"view-helpers/#settranslatortextdomain","text":"setTranslatorTextDomain(string $textDomain) : void Sets the default translation text domain to use with the helper.","title":"setTranslatorTextDomain()"},{"location":"view-helpers/#gettranslatortextdomain","text":"getTranslatorTextDomain() : string Returns the current text domain used by the helper.","title":"getTranslatorTextDomain()"}]}