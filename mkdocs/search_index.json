{
    "docs": [
        {
            "location": "/",
            "text": "zend-i18n\n\n\n\n\n\n\nZend\\I18n\n comes with a complete translation suite which supports all major\nformats and includes popular features like plural translations and text domains.\nThe Translator component is mostly dependency free, except for the fallback to a\ndefault locale, where it relies on the Intl PHP extension.\n\n\nThe translator itself is initialized without any parameters, as any configuration\nto it is optional. A translator without any translations will actually do nothing\nbut just return the given message IDs.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-i18n/issues\n\n\nDocumentation is at https://zendframework.github.io/zend-i18n/",
            "title": "Home"
        },
        {
            "location": "/#zend-i18n",
            "text": "Zend\\I18n  comes with a complete translation suite which supports all major\nformats and includes popular features like plural translations and text domains.\nThe Translator component is mostly dependency free, except for the fallback to a\ndefault locale, where it relies on the Intl PHP extension.  The translator itself is initialized without any parameters, as any configuration\nto it is optional. A translator without any translations will actually do nothing\nbut just return the given message IDs.   File issues at https://github.com/zendframework/zend-i18n/issues  Documentation is at https://zendframework.github.io/zend-i18n/",
            "title": "zend-i18n"
        },
        {
            "location": "/translation/",
            "text": "Translation\n\n\nzend-i18n comes with a complete translation suite supporting all major formats\nand including popular features such as plural translations and text domains. The\nTranslator subcomponent is mostly dependency free, except for the fallback to a\ndefault locale, where it relies on the PHP's intl extension.\n\n\nThe translator itself is initialized without any parameters, as any\nconfiguration to it is optional. A translator without any translations will do\nnothing but return all messages verbatim.\n\n\nAdding translations\n\n\nTo options exist for adding translations to the translator:\n\n\n\n\nAdd every translation file individually; use this for translation formats that\n  store multiple locales in the same file.\n\n\nAdd translation files based on a pattern; use this for formats that use one\n  file per locale.\n\n\n\n\nTo add a single file to the translator, use the \naddTranslationFile()\n method:\n\n\nuse Zend\\I18n\\Translator\\Translator;\n\n$translator = new Translator();\n$translator->addTranslationFile($type, $filename, $textDomain, $locale);\n\n\n\n\nwhere the arguments are:\n\n\n\n\n$type\n: the name of the format loader to use; see the next section for\n  details.\n\n\n$filename\n: the file containing translations.\n\n\n$textDomain\n: a \"category\" name for translations. If this is omitted, it\n  defaults to \"default\". Use text domains to segregate translations by context.\n\n\n$locale\n: the language strings are translated from; this argument is only\n  required for formats which contain translations for single locales.\n\n\n\n\n\n\nText domain and locale are related\n\n\nFor each text domain and locale combination, there can only be one file\nloaded. Every successive file would override the translations which were\nloaded prior.\n\n\n\n\nWhen storing one locale per file, you should specify those files via a pattern.\nThis allows you to add new translations to the file system, without touching\nyour code. Patterns are added with the \naddTranslationFilePattern()\n method:\n\n\nuse Zend\\I18n\\Translator\\Translator;\n\n$translator = new Translator();\n$translator->addTranslationFilePattern($type, $baseDir, $pattern, $textDomain);\n\n\n\n\nwhere the arguments are roughly the same as for \naddTranslationFile()\n, with a\nfew differences:\n\n\n\n\n$baseDir\n is a directory containing translation files.\n\n\n$pattern\n is an \nsprintf()\n-formatted string describing a pattern for\n  locating files under \n$baseDir\n. The \n$pattern\n should contain a substitution\n  character for the \n$locale\n \u2014 which is omitted from the\n  \naddTranslationFilePattern()\n call, but passed whenever a translation is\n  requested. Use either \n%s\n or \n%1$s\n in the \n$pattern\n as a placeholder for\n  the locale. As an example, if your translation files are located in\n  \n/var/messages/<LOCALE>/messages.mo\n, your pattern would be\n  \n/var/messages/%s/messages.mo\n.\n\n\n\n\nSupported formats\n\n\nThe translator supports the following major translation formats:\n\n\n\n\nPHP arrays\n\n\nGettext\n\n\nINI\n\n\n\n\nAdditionally, you can use custom formats by implementing one or more of\n\nZend\\I18n\\Translator\\Loader\\FileLoaderInterface\n or\n\nZend\\I18n\\Translator\\Loader\\RemoteLoaderInterface\n, and registering your loader\nwith the \nTranslator\n instance's composed plugin manager.\n\n\nSetting a locale\n\n\nBy default, the translator will get the locale to use from ext/intl's \nLocale\n\nclass. If you want to set an alternative locale explicitly, you can do so by\npassing it to the \nsetLocale()\n method.\n\n\nWhen there is no translation for a specific message identifier in a locale, the\nmessage identifier itself will be returned by default. Alternately, you can set\na fallback locale which is used to retrieve a fallback translation. To do so,\npass it to the \nsetFallbackLocale()\n method.\n\n\nTranslating messages\n\n\nTranslating messages is accomplished by calling the \ntranslate()\n method of the\ntranslator:\n\n\n$translator->translate($message, $textDomain, $locale);\n\n\n\n\nThe message is the message identifier to translate. If it does not exist in the\nloader, or is empty, the original message ID will be returned. The text domain\nparameter is the one you specified when adding translations. If omitted, the\n\"default\" text domain will be used. The locale parameter will usually not be\nused in this context, as by default the locale is taken from the locale set in\nthe translator.\n\n\nTo translate plural messages, you can use the \ntranslatePlural()\n method. It\nworks similarly to \ntranslate()\n, but instead of a single message, it takes a\nsingular value, a plural value, and an additional integer number on which the\nreturned plural form is based:\n\n\n$translator->translatePlural($singular, $plural, $number, $textDomain, $locale);\n\n\n\n\nPlural translations are only available if the underlying format supports the\ntranslation of plural messages and plural rule definitions.\n\n\nCaching\n\n\nIn production, it makes sense to cache your translations. This not only saves\nyou from loading and parsing the individual formats each time, but also\nguarantees an optimized loading procedure. To enable caching, pass a\n\nZend\\Cache\\Storage\\Adapter\n to the \nsetCache()\n method. To disable the cache,\npass a \nnull\n value to the method.",
            "title": "Translation"
        },
        {
            "location": "/translation/#translation",
            "text": "zend-i18n comes with a complete translation suite supporting all major formats\nand including popular features such as plural translations and text domains. The\nTranslator subcomponent is mostly dependency free, except for the fallback to a\ndefault locale, where it relies on the PHP's intl extension.  The translator itself is initialized without any parameters, as any\nconfiguration to it is optional. A translator without any translations will do\nnothing but return all messages verbatim.",
            "title": "Translation"
        },
        {
            "location": "/translation/#adding-translations",
            "text": "To options exist for adding translations to the translator:   Add every translation file individually; use this for translation formats that\n  store multiple locales in the same file.  Add translation files based on a pattern; use this for formats that use one\n  file per locale.   To add a single file to the translator, use the  addTranslationFile()  method:  use Zend\\I18n\\Translator\\Translator;\n\n$translator = new Translator();\n$translator->addTranslationFile($type, $filename, $textDomain, $locale);  where the arguments are:   $type : the name of the format loader to use; see the next section for\n  details.  $filename : the file containing translations.  $textDomain : a \"category\" name for translations. If this is omitted, it\n  defaults to \"default\". Use text domains to segregate translations by context.  $locale : the language strings are translated from; this argument is only\n  required for formats which contain translations for single locales.",
            "title": "Adding translations"
        },
        {
            "location": "/translation/#text-domain-and-locale-are-related",
            "text": "For each text domain and locale combination, there can only be one file\nloaded. Every successive file would override the translations which were\nloaded prior.   When storing one locale per file, you should specify those files via a pattern.\nThis allows you to add new translations to the file system, without touching\nyour code. Patterns are added with the  addTranslationFilePattern()  method:  use Zend\\I18n\\Translator\\Translator;\n\n$translator = new Translator();\n$translator->addTranslationFilePattern($type, $baseDir, $pattern, $textDomain);  where the arguments are roughly the same as for  addTranslationFile() , with a\nfew differences:   $baseDir  is a directory containing translation files.  $pattern  is an  sprintf() -formatted string describing a pattern for\n  locating files under  $baseDir . The  $pattern  should contain a substitution\n  character for the  $locale  \u2014 which is omitted from the\n   addTranslationFilePattern()  call, but passed whenever a translation is\n  requested. Use either  %s  or  %1$s  in the  $pattern  as a placeholder for\n  the locale. As an example, if your translation files are located in\n   /var/messages/<LOCALE>/messages.mo , your pattern would be\n   /var/messages/%s/messages.mo .",
            "title": "Text domain and locale are related"
        },
        {
            "location": "/translation/#supported-formats",
            "text": "The translator supports the following major translation formats:   PHP arrays  Gettext  INI   Additionally, you can use custom formats by implementing one or more of Zend\\I18n\\Translator\\Loader\\FileLoaderInterface  or Zend\\I18n\\Translator\\Loader\\RemoteLoaderInterface , and registering your loader\nwith the  Translator  instance's composed plugin manager.",
            "title": "Supported formats"
        },
        {
            "location": "/translation/#setting-a-locale",
            "text": "By default, the translator will get the locale to use from ext/intl's  Locale \nclass. If you want to set an alternative locale explicitly, you can do so by\npassing it to the  setLocale()  method.  When there is no translation for a specific message identifier in a locale, the\nmessage identifier itself will be returned by default. Alternately, you can set\na fallback locale which is used to retrieve a fallback translation. To do so,\npass it to the  setFallbackLocale()  method.",
            "title": "Setting a locale"
        },
        {
            "location": "/translation/#translating-messages",
            "text": "Translating messages is accomplished by calling the  translate()  method of the\ntranslator:  $translator->translate($message, $textDomain, $locale);  The message is the message identifier to translate. If it does not exist in the\nloader, or is empty, the original message ID will be returned. The text domain\nparameter is the one you specified when adding translations. If omitted, the\n\"default\" text domain will be used. The locale parameter will usually not be\nused in this context, as by default the locale is taken from the locale set in\nthe translator.  To translate plural messages, you can use the  translatePlural()  method. It\nworks similarly to  translate() , but instead of a single message, it takes a\nsingular value, a plural value, and an additional integer number on which the\nreturned plural form is based:  $translator->translatePlural($singular, $plural, $number, $textDomain, $locale);  Plural translations are only available if the underlying format supports the\ntranslation of plural messages and plural rule definitions.",
            "title": "Translating messages"
        },
        {
            "location": "/translation/#caching",
            "text": "In production, it makes sense to cache your translations. This not only saves\nyou from loading and parsing the individual formats each time, but also\nguarantees an optimized loading procedure. To enable caching, pass a Zend\\Cache\\Storage\\Adapter  to the  setCache()  method. To disable the cache,\npass a  null  value to the method.",
            "title": "Caching"
        },
        {
            "location": "/view-helpers/",
            "text": "View Helpers\n\n\nzend-i18n ships with a set of zend-view helper classes related to\ninternationalization: e.g., formatting a date, formatting currency, or\ndisplaying translated content.\n\n\nSee the \nzend-view helpers documentation\n\nfor more information.\n\n\nCurrencyFormat Helper\n\n\nThe \nCurrencyFormat\n view helper can be used to simplify rendering of localized\ncurrency values. It acts as a wrapper for the \nNumberFormatter\n class within the\ninternationalization extension (ext/intl).\n\n\nBasic Usage\n\n\n// Within your view:\n\necho $this->currencyFormat(1234.56, 'USD', null, 'en_US');\n// Returns: \"$1,234.56\"\n\necho $this->currencyFormat(1234.56, 'EUR', null, 'de_DE');\n// Returns: \"1.234,56 \u20ac\"\n\necho $this->currencyFormat(1234.56, 'USD', true, 'en_US');\n// Returns: \"$1,234.56\"\n\necho $this->currencyFormat(1234.56, 'USD', false, 'en_US');\n// Returns: \"$1,235\"\n\necho $this->currencyFormat(12345678.90, 'EUR', true, 'de_DE', '#0.# kg');\n// Returns: \"12345678,90 kg\"\n\necho $this->currencyFormat(12345678.90, 'EUR', false, 'de_DE', '#0.# kg');\n// Returns: \"12345679 kg\"\n\n\n\n\nMethod description\n\n\ncurrencyFormat(\n    float $number [,\n    string $currencyCode = null [,\n    bool $showDecimals = null [,\n    string $locale = null [,\n    string $pattern = null\n] ] ] ]) : string\n\n\n\n\nwhere:\n\n\n\n\n$number\n: the numeric currency value.\n\n\n$currencyCode\n: the 3-letter ISO 4217 currency code indicating the currency\n  to use. If unset, it will use the default value current in the helper\n  instance (\nnull\n by default).\n\n\n$showDecimals\n: Boolean \nfalse\n indicates that no decimals should be\n  represented. If unset, it will use the value current in the helper instance\n  (\ntrue\n by default).\n\n\n$locale\n: Locale in which the currency would be formatted (locale name, e.g.\n  \nen_US\n). If unset, it will use the default locale (default is the value of\n  \nLocale::getDefault()\n).\n\n\n$pattern\n: Pattern string the formatter should use. If unset, it will use the\n  value current in the helper instance (\nnull\n by default).\n\n\n\n\nAvailable Functionality\n\n\nSet the currency code and the locale\n\n\nThe \n$currencyCode\n and \n$locale\n options can be set prior to formatting and\nwill be applied each time the helper is used:\n\n\n// Within your view\n\n$this->plugin('currencyformat')->setCurrencyCode('USD')->setLocale('en_US');\n\necho $this->currencyFormat(1234.56);\n// This returns: \"$1,234.56\"\n\necho $this->currencyFormat(5678.90);\n// This returns: \"$5,678.90\"\n\n\n\n\nThe method signatures are:\n\n\nsetCurrencyCode(string $currencyCode) : CurrencyFormat\n\n\n\n\nwhere \n$currencyCode\n is the 3-letter ISO 4217 currency code, and\n\n\nsetLocale(string $locale) : CurrencyFormat\n\n\n\n\nwhere \n$locale\n is the locale with which to format the number.\n\n\nShow decimals\n\n\n// Within your view\n\n$this->plugin('currencyformat')->setShouldShowDecimals(false);\n\necho $this->currencyFormat(1234.56, 'USD', null, 'en_US');\n// This returns: \"$1,235\"\n\n\n\n\nwith the following method signature:\n\n\nsetShouldShowDecimals(bool $showDecimals) : CurrencyFormat\n\n\n\n\nwhere \n$showDecimals\n indicates whether or not decimal values will be displayed.\n\n\nSet the currency pattern\n\n\n// Within your view\n\n$this->plugin('currencyformat')->setCurrencyPattern('#0.# kg');\n\necho $this->currencyFormat(12345678.90, 'EUR', null, 'de_DE');\n// This returns: \"12345678,90 kg\"\n\n\n\n\nwith the following method signature:\n\n\nsetCurrencyPattern(string $currencyPattern) : CurrencyFormat\n\n\n\n\nwhere \n$currencyPattern\n is a valid \nICU DecimalFormat pattern\n;\nsee the \nNumberFormatter::setPattern() documentation\n\nfor more information.\n\n\nDateFormat Helper\n\n\nThe \nDateFormat\n view helper can be used to simplify rendering of localized\ndate/time values. It acts as a wrapper for the \nIntlDateFormatter\n class within\next/intl.\n\n\nBasic Usage\n\n\n// Within your view\n\n// Date and Time\necho $this->dateFormat(\n    new DateTime(),\n    IntlDateFormatter::MEDIUM, // date\n    IntlDateFormatter::MEDIUM, // time\n    \"en_US\"\n);\n// This returns: \"Jul 2, 2012 6:44:03 PM\"\n\n// Date Only\necho $this->dateFormat(\n    new DateTime(),\n    IntlDateFormatter::LONG, // date\n    IntlDateFormatter::NONE, // time\n    \"en_US\"\n);\n// This returns: \"July 2, 2012\"\n\n// Time Only\necho $this->dateFormat(\n    new DateTime(),\n    IntlDateFormatter::NONE,  // date\n    IntlDateFormatter::SHORT, // time\n    \"en_US\"\n);\n// This returns: \"6:44 PM\"\n\n\n\n\nMethod description\n\n\ndateFormat(\n    mixed $date [,\n    int $dateType = null [,\n    int $timeType = null [,\n    string $locale = null\n] ] ]) : string\n\n\n\n\nwhere:\n\n\n\n\n$date\n: The value to format. This may be a \nDateTime\n instance, an integer\n  representing a Unix timestamp value, or an array in the format returned by\n  \nlocaltime()\n.\n\n\n$dateType\n: Date type to use (none, short, medium, long, full). This is one\n  of the \nIntlDateFormatter constants\n.\n  Defaults to \nIntlDateFormatter::NONE\n.\n\n\n$timeType\n: Time type to use (none, short, medium, long, full). This is one\n  of the \nIntlDateFormatter constants\n.\n  Defaults to \nIntlDateFormatter::NONE\n.\n\n\n$locale\n: Locale in which the date would be formatted (locale name, e.g.\n  \nen_US\n). If unset, it will use the default locale (return value of\n  \nLocale::getDefault()\n).\n\n\n\n\nPublic Methods\n\n\nThe \n$locale\n option can be set prior to formatting with the \nsetLocale()\n\nmethod and will be applied each time the helper is used.\n\n\nBy default, the system's default timezone will be used when formatting. This\noverrides any timezone that may be set inside a \nDateTime\n object. To change the\ntimezone when formatting, use the \nsetTimezone()\n method.\n\n\n// Within your view\n$this->plugin('dateFormat')\n    ->setTimezone('America/New_York')\n    ->setLocale('en_US');\n\necho $this->dateFormat(new DateTime(), IntlDateFormatter::MEDIUM);  // \"Jul 2, 2012\"\necho $this->dateFormat(new DateTime(), IntlDateFormatter::SHORT);   // \"7/2/12\"\n\n\n\n\nNumberFormat Helper\n\n\nThe \nNumberFormat\n view helper can be used to simplify rendering of\nlocale-specific number and/or percentage strings. It acts as a wrapper for the\n\nNumberFormatter\n class within ext/intl.\n\n\nBasic Usage\n\n\n// Within your view\n\n// Example of Decimal formatting:\necho $this->numberFormat(\n    1234567.891234567890000,\n    NumberFormatter::DECIMAL,\n    NumberFormatter::TYPE_DEFAULT,\n    'de_DE'\n);\n// This returns: \"1.234.567,891\"\n\n// Example of Percent formatting:\necho $this->numberFormat(\n    0.80,\n    NumberFormatter::PERCENT,\n    NumberFormatter::TYPE_DEFAULT,\n    'en_US'\n);\n// This returns: \"80%\"\n\n// Example of Scientific notation formatting:\necho $this->numberFormat(\n    0.00123456789,\n    NumberFormatter::SCIENTIFIC,\n    NumberFormatter::TYPE_DEFAULT,\n    'fr_FR'\n);\n// This returns: \"1,23456789E-3\"\n\n\n\n\nMethod description\n\n\nnumberFormat(\n    int|float $number [,\n    int $formatStyle = null [,\n    int $formatType = null [,\n    string $locale = null [,\n    int $decimals = null [,\n    array $textAttributes = null\n] ] ] ] ]) : string\n\n\n\n\nwhere:\n\n\n\n\n$number\n: the number to format.\n\n\n$formatStyle\n: one of the \nNumberFormatter\n styles:\n  \nNumberFormatter::DECIMAL\n, \nNumberFormatter::CURRENCY\n, etc.\n\n\n$formatType\n: one of the \nNumberFormatter\n types:\n  \nNumberFormatter::TYPE_DEFAULT\n (basic numeric),\n  \nNumberFormatter::TYPE_CURRENCY\n, etc.\n\n\n$locale\n: a valid locale to use when formatting the number.\n\n\n$decimals\n: the number of digits beyond the decimal point to display.\n\n\n$textAttributes\n: text attributes to use with the number (e.g., prefix and/or\n  suffix for positive/negative numbers, currency code):\n  \nNumberFormatter::POSITIVE_PREFIX\n, \nNumberFormatter::NEGATIVE_PREFIX\n, etc.\n\n\n\n\nPublic Methods\n\n\nEach of the \n$formatStyle\n, \n$formatType\n, \n$locale\n, and \n$textAttributes\n\noptions can be set prior to formatting and will be applied each time the helper\nis used.\n\n\n// Within your view\n$this->plugin(\"numberformat\")\n            ->setFormatStyle(NumberFormatter::PERCENT)\n            ->setFormatType(NumberFormatter::TYPE_DOUBLE)\n            ->setLocale(\"en_US\")\n            ->setTextAttributes([\n                NumberFormatter::POSITIVE_PREFIX => '^ ',\n                NumberFormatter::NEGATIVE_PREFIX => 'v ',\n            ]);\n\necho $this->numberFormat(0.56);   // \"^ 56%\"\necho $this->numberFormat(-0.90);  // \"v 90%\"\n\n\n\n\nPlural Helper\n\n\nMost languages have specific rules for handling plurals. For instance, in\nEnglish, we say \"0 cars\" and \"2 cars\" (plural) while we say \"1 car\" (singular).\nOn the other hand, French uses the singular form for both 0 and 1 (\"0 voiture\"\nand \"1 voiture\") and the plural form otherwise (\"3 voitures\").\n\n\nTherefore we often need to handle plural cases even without translation (mono-lingual\napplication). The \nPlural\n helper was created for this.\n\n\n\n\nPlural helper does not translate\n\n\nIf you need to handle both plural cases \nand\n translations, you must use the\n\nTranslatePlural\n helper; \nPlural\n does not translate.\n\n\n\n\nInternally, the \nPlural\n helper uses the \nZend\\I18n\\Translator\\Plural\\Rule\n class to handle rules.\n\n\nSetup\n\n\nDefining plural rules is left to the developer. To help you with this process,\nhere are some links with up-to-date plural rules for tons of languages:\n\n\n\n\nhttp://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\n\n\nhttps://developer.mozilla.org/en-US/docs/Localization_and_Plurals\n\n\n\n\nBasic Usage\n\n\nFirst, define a rule. As an example, you could add the following code in your\n\nModule\n class:\n\n\n// Get the ViewHelperPlugin Manager from the ServiceManager, so we can fetch the\n// Plural helper and add the plural rule for the application's language:\n$viewHelperManager = $serviceManager->get('ViewHelperManager');\n$pluralHelper      = $viewHelperManager->get('Plural');\n\n// Here is the rule for French\n$pluralHelper->setPluralRule('nplurals=2; plural=(n==0 || n==1 ? 0 : 1)');\n\n\n\n\nThe string reads as follows:\n\n\n\n\nFirst, we specify how many plural forms we have. For French, only two (singular/plural).\n\n\nNext, we specify the rule. Here, if the count is 0 or 1, this is rule n\u00b00\n   (singular) while it's rule n\u00b01 otherwise.\n\n\n\n\nAs noted earlier earlier, English considers \"1\" as singular and \"0/other\" as\nplural. Here is how that would be declared:\n\n\n// Here is the rule for English\n$pluralHelper->setPluralRule('nplurals=2; plural=(n==1 ? 0 : 1)');\n\n\n\n\nNow that we have defined the rule, we can use it in our views:\n\n\n// Within a view script...\n// If the rule defined in Module.php is the English one:\n\necho $this->plural(array('car', 'cars'), 0); // prints \"cars\"\necho $this->plural(array('car', 'cars'), 1); // prints \"car\"\n\n// If the rule defined in Module.php is the French one:\necho $this->plural(array('voiture', 'voitures'), 0); // prints \"voiture\"\necho $this->plural(array('voiture', 'voitures'), 1); // prints \"voiture\"\necho $this->plural(array('voiture', 'voitures'), 2); // prints \"voitures\"\n\n\n\n\nTranslate Helper\n\n\nThe \nTranslate\n view helper can be used to translate content. It acts as a\nwrapper for the \nZend\\I18n\\Translator\\Translator\n class.\n\n\nSetup\n\n\nBefore using the \nTranslate\n view helper, you must have first created a\n\nTranslator\n object and have attached it to the view helper. If you use the\n\nZend\\View\\HelperPluginManager\n to invoke the view helper, this will be done\nautomatically for you.\n\n\nBasic Usage\n\n\n// Within your view...\n\necho $this->translate(\"Some translated text.\");\necho $this->translate(\"Translated text from a custom text domain.\", \"customDomain\");\necho sprintf($this->translate(\"The current time is %s.\"), $currentTime);\necho $this->translate(\"Translate in a specific locale\", \"default\", \"de_DE\");\n\n\n\n\nMethod description\n\n\ntranslate(\n    string $message [,\n    string $textDomain = null [,\n    string $locale = null\n] ]) : string\n\n\n\n\nwhere:\n\n\n\n\n$message\n: The message to translate.\n\n\n$textDomain\n: The text domain/context of the translation; defaults to\n  \"default\".\n\n\n$locale\n: Locale to which the message should be translated (locale name, e.g.\n  \nen_US\n). If unset, it will use the default locale (return value of\n  \nLocale::getDefault()\n).\n\n\n\n\nGettext\n\n\nThe \nxgettext\n utility can be used to compile \n*.po\n files from PHP source files containing the\ntranslate view helper.\n\n\n$ xgettext --language=php --add-location --keyword=translate my-view-file.phtml\n\n\n\n\nSee the \nGettext Wikipedia page\n for more information.\n\n\nPublic Methods\n\n\nPublic methods for setting a \nZend\\I18n\\Translator\\Translator\n and a default\ntext domain are inherited from the \nAbstractTranslatorHelper\n.\n\n\nTranslatePlural Helper\n\n\nThe \nTranslatePlural\n view helper can be used to translate words which take into\naccount numeric meanings. English, for example, has a singular definition of\n\"car\", for one car, and the plural definition, \"cars\", meaning zero \"cars\"\nor more than one car. Other languages like Russian or Polish have more plurals\nwith different rules.\n\n\nThe helper acts as a wrapper for the \nZend\\I18n\\Translator\\Translator\n class.\n\n\nSetup\n\n\nBefore using the \nTranslatePlural\n view helper, you must have first created a\n\nTranslator\n object and have attached it to the view helper. If you use the\n\nZend\\View\\HelperPluginManager\n to invoke the view helper, this will be done\nautomatically for you.\n\n\nBasic Usage\n\n\n// Within your view\necho $this->translatePlural(\"car\", \"cars\", $num);\n\n// Use a custom domain\necho $this->translatePlural(\"monitor\", \"monitors\", $num, \"customDomain\");\n\n// Change locale\necho $this->translatePlural(\"locale\", \"locales\", $num, \"default\", \"de_DE\");\n\n\n\n\nMethod description\n\n\ntranslatePlural(\n    string $singular,\n    string $plural,\n    int $number [,\n    string $textDomain = null [,\n    string $locale = null\n] ]) : string\n\n\n\n\nwhere:\n\n\n\n\n$singular\n: The message to use for singular values.\n\n\n$plural\n: The message to use for plural values.\n\n\n$number\n: The number to evaluate in order to determine which number to use.\n\n\n$textDomain\n: The text domain/context of the translation; defaults to\n  \"default\".\n\n\n$locale\n: Locale to which the message should be translated (locale name, e.g.\n  \nen_US\n). If unset, it will use the default locale (return value of\n  \nLocale::getDefault()\n).\n\n\n\n\nPublic Methods\n\n\nPublic methods for setting a \nZend\\I18n\\Translator\\Translator\n and a default\ntext domain are inherited from the \nAbstractTranslatorHelper\n.\n\n\nAbstract Translator Helper\n\n\nThe \nAbstractTranslatorHelper\n view helper is used as a base abstract class for\nany helpers that need to translate content. It provides an implementation for\nthe \nZend\\I18n\\Translator\\TranslatorAwareInterface\n, allowing translator\ninjection as well as text domain injection.\n\n\nPublic Methods\n\n\nsetTranslator()\n\n\nsetTranslator(\n    Translator $translator [ ,\n    string $textDomain = null\n] ) : void\n\n\n\n\nSets the \nZend\\I18n\\Translator\\Translator\n instance to use in the helper. The\n\n$textDomain\n argument is optional, and provided as a convenienct to allow\nsetting both the translator and text domain simultaneously.\n\n\ngetTranslator()\n\n\ngetTranslator() : Translator\n\n\n\n\nReturns the \nZend\\I18n\\Translator\\Translator\n instance used by the helper.\n\n\nhasTranslator()\n\n\nhasTranslator() : bool\n\n\n\n\nReturns true if the helper composes a \nZend\\I18n\\Translator\\Translator\n instance.\n\n\nsetTranslatorEnabled()\n\n\nsetTranslatorEnabled(bool $enabled) : void\n\n\n\n\nSets whether or not translations are enabled.\n\n\nisTranslatorEnabled()\n\n\nisTranslatorEnabled() : bool\n\n\n\n\nReturns true if translations are enabled.\n\n\nsetTranslatorTextDomain()\n\n\nsetTranslatorTextDomain(string $textDomain) : void\n\n\n\n\nSets the default translation text domain to use with the helper.\n\n\ngetTranslatorTextDomain()\n\n\ngetTranslatorTextDomain() : string\n\n\n\n\nReturns the current text domain used by the helper.",
            "title": "View Helpers"
        },
        {
            "location": "/view-helpers/#view-helpers",
            "text": "zend-i18n ships with a set of zend-view helper classes related to\ninternationalization: e.g., formatting a date, formatting currency, or\ndisplaying translated content.  See the  zend-view helpers documentation \nfor more information.",
            "title": "View Helpers"
        },
        {
            "location": "/view-helpers/#currencyformat-helper",
            "text": "The  CurrencyFormat  view helper can be used to simplify rendering of localized\ncurrency values. It acts as a wrapper for the  NumberFormatter  class within the\ninternationalization extension (ext/intl).",
            "title": "CurrencyFormat Helper"
        },
        {
            "location": "/view-helpers/#basic-usage",
            "text": "// Within your view:\n\necho $this->currencyFormat(1234.56, 'USD', null, 'en_US');\n// Returns: \"$1,234.56\"\n\necho $this->currencyFormat(1234.56, 'EUR', null, 'de_DE');\n// Returns: \"1.234,56 \u20ac\"\n\necho $this->currencyFormat(1234.56, 'USD', true, 'en_US');\n// Returns: \"$1,234.56\"\n\necho $this->currencyFormat(1234.56, 'USD', false, 'en_US');\n// Returns: \"$1,235\"\n\necho $this->currencyFormat(12345678.90, 'EUR', true, 'de_DE', '#0.# kg');\n// Returns: \"12345678,90 kg\"\n\necho $this->currencyFormat(12345678.90, 'EUR', false, 'de_DE', '#0.# kg');\n// Returns: \"12345679 kg\"",
            "title": "Basic Usage"
        },
        {
            "location": "/view-helpers/#method-description",
            "text": "currencyFormat(\n    float $number [,\n    string $currencyCode = null [,\n    bool $showDecimals = null [,\n    string $locale = null [,\n    string $pattern = null\n] ] ] ]) : string  where:   $number : the numeric currency value.  $currencyCode : the 3-letter ISO 4217 currency code indicating the currency\n  to use. If unset, it will use the default value current in the helper\n  instance ( null  by default).  $showDecimals : Boolean  false  indicates that no decimals should be\n  represented. If unset, it will use the value current in the helper instance\n  ( true  by default).  $locale : Locale in which the currency would be formatted (locale name, e.g.\n   en_US ). If unset, it will use the default locale (default is the value of\n   Locale::getDefault() ).  $pattern : Pattern string the formatter should use. If unset, it will use the\n  value current in the helper instance ( null  by default).",
            "title": "Method description"
        },
        {
            "location": "/view-helpers/#available-functionality",
            "text": "",
            "title": "Available Functionality"
        },
        {
            "location": "/view-helpers/#set-the-currency-code-and-the-locale",
            "text": "The  $currencyCode  and  $locale  options can be set prior to formatting and\nwill be applied each time the helper is used:  // Within your view\n\n$this->plugin('currencyformat')->setCurrencyCode('USD')->setLocale('en_US');\n\necho $this->currencyFormat(1234.56);\n// This returns: \"$1,234.56\"\n\necho $this->currencyFormat(5678.90);\n// This returns: \"$5,678.90\"  The method signatures are:  setCurrencyCode(string $currencyCode) : CurrencyFormat  where  $currencyCode  is the 3-letter ISO 4217 currency code, and  setLocale(string $locale) : CurrencyFormat  where  $locale  is the locale with which to format the number.",
            "title": "Set the currency code and the locale"
        },
        {
            "location": "/view-helpers/#show-decimals",
            "text": "// Within your view\n\n$this->plugin('currencyformat')->setShouldShowDecimals(false);\n\necho $this->currencyFormat(1234.56, 'USD', null, 'en_US');\n// This returns: \"$1,235\"  with the following method signature:  setShouldShowDecimals(bool $showDecimals) : CurrencyFormat  where  $showDecimals  indicates whether or not decimal values will be displayed.",
            "title": "Show decimals"
        },
        {
            "location": "/view-helpers/#set-the-currency-pattern",
            "text": "// Within your view\n\n$this->plugin('currencyformat')->setCurrencyPattern('#0.# kg');\n\necho $this->currencyFormat(12345678.90, 'EUR', null, 'de_DE');\n// This returns: \"12345678,90 kg\"  with the following method signature:  setCurrencyPattern(string $currencyPattern) : CurrencyFormat  where  $currencyPattern  is a valid  ICU DecimalFormat pattern ;\nsee the  NumberFormatter::setPattern() documentation \nfor more information.",
            "title": "Set the currency pattern"
        },
        {
            "location": "/view-helpers/#dateformat-helper",
            "text": "The  DateFormat  view helper can be used to simplify rendering of localized\ndate/time values. It acts as a wrapper for the  IntlDateFormatter  class within\next/intl.",
            "title": "DateFormat Helper"
        },
        {
            "location": "/view-helpers/#basic-usage_1",
            "text": "// Within your view\n\n// Date and Time\necho $this->dateFormat(\n    new DateTime(),\n    IntlDateFormatter::MEDIUM, // date\n    IntlDateFormatter::MEDIUM, // time\n    \"en_US\"\n);\n// This returns: \"Jul 2, 2012 6:44:03 PM\"\n\n// Date Only\necho $this->dateFormat(\n    new DateTime(),\n    IntlDateFormatter::LONG, // date\n    IntlDateFormatter::NONE, // time\n    \"en_US\"\n);\n// This returns: \"July 2, 2012\"\n\n// Time Only\necho $this->dateFormat(\n    new DateTime(),\n    IntlDateFormatter::NONE,  // date\n    IntlDateFormatter::SHORT, // time\n    \"en_US\"\n);\n// This returns: \"6:44 PM\"",
            "title": "Basic Usage"
        },
        {
            "location": "/view-helpers/#method-description_1",
            "text": "dateFormat(\n    mixed $date [,\n    int $dateType = null [,\n    int $timeType = null [,\n    string $locale = null\n] ] ]) : string  where:   $date : The value to format. This may be a  DateTime  instance, an integer\n  representing a Unix timestamp value, or an array in the format returned by\n   localtime() .  $dateType : Date type to use (none, short, medium, long, full). This is one\n  of the  IntlDateFormatter constants .\n  Defaults to  IntlDateFormatter::NONE .  $timeType : Time type to use (none, short, medium, long, full). This is one\n  of the  IntlDateFormatter constants .\n  Defaults to  IntlDateFormatter::NONE .  $locale : Locale in which the date would be formatted (locale name, e.g.\n   en_US ). If unset, it will use the default locale (return value of\n   Locale::getDefault() ).",
            "title": "Method description"
        },
        {
            "location": "/view-helpers/#public-methods",
            "text": "The  $locale  option can be set prior to formatting with the  setLocale() \nmethod and will be applied each time the helper is used.  By default, the system's default timezone will be used when formatting. This\noverrides any timezone that may be set inside a  DateTime  object. To change the\ntimezone when formatting, use the  setTimezone()  method.  // Within your view\n$this->plugin('dateFormat')\n    ->setTimezone('America/New_York')\n    ->setLocale('en_US');\n\necho $this->dateFormat(new DateTime(), IntlDateFormatter::MEDIUM);  // \"Jul 2, 2012\"\necho $this->dateFormat(new DateTime(), IntlDateFormatter::SHORT);   // \"7/2/12\"",
            "title": "Public Methods"
        },
        {
            "location": "/view-helpers/#numberformat-helper",
            "text": "The  NumberFormat  view helper can be used to simplify rendering of\nlocale-specific number and/or percentage strings. It acts as a wrapper for the NumberFormatter  class within ext/intl.",
            "title": "NumberFormat Helper"
        },
        {
            "location": "/view-helpers/#basic-usage_2",
            "text": "// Within your view\n\n// Example of Decimal formatting:\necho $this->numberFormat(\n    1234567.891234567890000,\n    NumberFormatter::DECIMAL,\n    NumberFormatter::TYPE_DEFAULT,\n    'de_DE'\n);\n// This returns: \"1.234.567,891\"\n\n// Example of Percent formatting:\necho $this->numberFormat(\n    0.80,\n    NumberFormatter::PERCENT,\n    NumberFormatter::TYPE_DEFAULT,\n    'en_US'\n);\n// This returns: \"80%\"\n\n// Example of Scientific notation formatting:\necho $this->numberFormat(\n    0.00123456789,\n    NumberFormatter::SCIENTIFIC,\n    NumberFormatter::TYPE_DEFAULT,\n    'fr_FR'\n);\n// This returns: \"1,23456789E-3\"",
            "title": "Basic Usage"
        },
        {
            "location": "/view-helpers/#method-description_2",
            "text": "numberFormat(\n    int|float $number [,\n    int $formatStyle = null [,\n    int $formatType = null [,\n    string $locale = null [,\n    int $decimals = null [,\n    array $textAttributes = null\n] ] ] ] ]) : string  where:   $number : the number to format.  $formatStyle : one of the  NumberFormatter  styles:\n   NumberFormatter::DECIMAL ,  NumberFormatter::CURRENCY , etc.  $formatType : one of the  NumberFormatter  types:\n   NumberFormatter::TYPE_DEFAULT  (basic numeric),\n   NumberFormatter::TYPE_CURRENCY , etc.  $locale : a valid locale to use when formatting the number.  $decimals : the number of digits beyond the decimal point to display.  $textAttributes : text attributes to use with the number (e.g., prefix and/or\n  suffix for positive/negative numbers, currency code):\n   NumberFormatter::POSITIVE_PREFIX ,  NumberFormatter::NEGATIVE_PREFIX , etc.",
            "title": "Method description"
        },
        {
            "location": "/view-helpers/#public-methods_1",
            "text": "Each of the  $formatStyle ,  $formatType ,  $locale , and  $textAttributes \noptions can be set prior to formatting and will be applied each time the helper\nis used.  // Within your view\n$this->plugin(\"numberformat\")\n            ->setFormatStyle(NumberFormatter::PERCENT)\n            ->setFormatType(NumberFormatter::TYPE_DOUBLE)\n            ->setLocale(\"en_US\")\n            ->setTextAttributes([\n                NumberFormatter::POSITIVE_PREFIX => '^ ',\n                NumberFormatter::NEGATIVE_PREFIX => 'v ',\n            ]);\n\necho $this->numberFormat(0.56);   // \"^ 56%\"\necho $this->numberFormat(-0.90);  // \"v 90%\"",
            "title": "Public Methods"
        },
        {
            "location": "/view-helpers/#plural-helper",
            "text": "Most languages have specific rules for handling plurals. For instance, in\nEnglish, we say \"0 cars\" and \"2 cars\" (plural) while we say \"1 car\" (singular).\nOn the other hand, French uses the singular form for both 0 and 1 (\"0 voiture\"\nand \"1 voiture\") and the plural form otherwise (\"3 voitures\").  Therefore we often need to handle plural cases even without translation (mono-lingual\napplication). The  Plural  helper was created for this.",
            "title": "Plural Helper"
        },
        {
            "location": "/view-helpers/#plural-helper-does-not-translate",
            "text": "If you need to handle both plural cases  and  translations, you must use the TranslatePlural  helper;  Plural  does not translate.   Internally, the  Plural  helper uses the  Zend\\I18n\\Translator\\Plural\\Rule  class to handle rules.",
            "title": "Plural helper does not translate"
        },
        {
            "location": "/view-helpers/#setup",
            "text": "Defining plural rules is left to the developer. To help you with this process,\nhere are some links with up-to-date plural rules for tons of languages:   http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html  https://developer.mozilla.org/en-US/docs/Localization_and_Plurals",
            "title": "Setup"
        },
        {
            "location": "/view-helpers/#basic-usage_3",
            "text": "First, define a rule. As an example, you could add the following code in your Module  class:  // Get the ViewHelperPlugin Manager from the ServiceManager, so we can fetch the\n// Plural helper and add the plural rule for the application's language:\n$viewHelperManager = $serviceManager->get('ViewHelperManager');\n$pluralHelper      = $viewHelperManager->get('Plural');\n\n// Here is the rule for French\n$pluralHelper->setPluralRule('nplurals=2; plural=(n==0 || n==1 ? 0 : 1)');  The string reads as follows:   First, we specify how many plural forms we have. For French, only two (singular/plural).  Next, we specify the rule. Here, if the count is 0 or 1, this is rule n\u00b00\n   (singular) while it's rule n\u00b01 otherwise.   As noted earlier earlier, English considers \"1\" as singular and \"0/other\" as\nplural. Here is how that would be declared:  // Here is the rule for English\n$pluralHelper->setPluralRule('nplurals=2; plural=(n==1 ? 0 : 1)');  Now that we have defined the rule, we can use it in our views:  // Within a view script...\n// If the rule defined in Module.php is the English one:\n\necho $this->plural(array('car', 'cars'), 0); // prints \"cars\"\necho $this->plural(array('car', 'cars'), 1); // prints \"car\"\n\n// If the rule defined in Module.php is the French one:\necho $this->plural(array('voiture', 'voitures'), 0); // prints \"voiture\"\necho $this->plural(array('voiture', 'voitures'), 1); // prints \"voiture\"\necho $this->plural(array('voiture', 'voitures'), 2); // prints \"voitures\"",
            "title": "Basic Usage"
        },
        {
            "location": "/view-helpers/#translate-helper",
            "text": "The  Translate  view helper can be used to translate content. It acts as a\nwrapper for the  Zend\\I18n\\Translator\\Translator  class.",
            "title": "Translate Helper"
        },
        {
            "location": "/view-helpers/#setup_1",
            "text": "Before using the  Translate  view helper, you must have first created a Translator  object and have attached it to the view helper. If you use the Zend\\View\\HelperPluginManager  to invoke the view helper, this will be done\nautomatically for you.",
            "title": "Setup"
        },
        {
            "location": "/view-helpers/#basic-usage_4",
            "text": "// Within your view...\n\necho $this->translate(\"Some translated text.\");\necho $this->translate(\"Translated text from a custom text domain.\", \"customDomain\");\necho sprintf($this->translate(\"The current time is %s.\"), $currentTime);\necho $this->translate(\"Translate in a specific locale\", \"default\", \"de_DE\");",
            "title": "Basic Usage"
        },
        {
            "location": "/view-helpers/#method-description_3",
            "text": "translate(\n    string $message [,\n    string $textDomain = null [,\n    string $locale = null\n] ]) : string  where:   $message : The message to translate.  $textDomain : The text domain/context of the translation; defaults to\n  \"default\".  $locale : Locale to which the message should be translated (locale name, e.g.\n   en_US ). If unset, it will use the default locale (return value of\n   Locale::getDefault() ).",
            "title": "Method description"
        },
        {
            "location": "/view-helpers/#gettext",
            "text": "The  xgettext  utility can be used to compile  *.po  files from PHP source files containing the\ntranslate view helper.  $ xgettext --language=php --add-location --keyword=translate my-view-file.phtml  See the  Gettext Wikipedia page  for more information.",
            "title": "Gettext"
        },
        {
            "location": "/view-helpers/#public-methods_2",
            "text": "Public methods for setting a  Zend\\I18n\\Translator\\Translator  and a default\ntext domain are inherited from the  AbstractTranslatorHelper .",
            "title": "Public Methods"
        },
        {
            "location": "/view-helpers/#translateplural-helper",
            "text": "The  TranslatePlural  view helper can be used to translate words which take into\naccount numeric meanings. English, for example, has a singular definition of\n\"car\", for one car, and the plural definition, \"cars\", meaning zero \"cars\"\nor more than one car. Other languages like Russian or Polish have more plurals\nwith different rules.  The helper acts as a wrapper for the  Zend\\I18n\\Translator\\Translator  class.",
            "title": "TranslatePlural Helper"
        },
        {
            "location": "/view-helpers/#setup_2",
            "text": "Before using the  TranslatePlural  view helper, you must have first created a Translator  object and have attached it to the view helper. If you use the Zend\\View\\HelperPluginManager  to invoke the view helper, this will be done\nautomatically for you.",
            "title": "Setup"
        },
        {
            "location": "/view-helpers/#basic-usage_5",
            "text": "// Within your view\necho $this->translatePlural(\"car\", \"cars\", $num);\n\n// Use a custom domain\necho $this->translatePlural(\"monitor\", \"monitors\", $num, \"customDomain\");\n\n// Change locale\necho $this->translatePlural(\"locale\", \"locales\", $num, \"default\", \"de_DE\");",
            "title": "Basic Usage"
        },
        {
            "location": "/view-helpers/#method-description_4",
            "text": "translatePlural(\n    string $singular,\n    string $plural,\n    int $number [,\n    string $textDomain = null [,\n    string $locale = null\n] ]) : string  where:   $singular : The message to use for singular values.  $plural : The message to use for plural values.  $number : The number to evaluate in order to determine which number to use.  $textDomain : The text domain/context of the translation; defaults to\n  \"default\".  $locale : Locale to which the message should be translated (locale name, e.g.\n   en_US ). If unset, it will use the default locale (return value of\n   Locale::getDefault() ).",
            "title": "Method description"
        },
        {
            "location": "/view-helpers/#public-methods_3",
            "text": "Public methods for setting a  Zend\\I18n\\Translator\\Translator  and a default\ntext domain are inherited from the  AbstractTranslatorHelper .",
            "title": "Public Methods"
        },
        {
            "location": "/view-helpers/#abstract-translator-helper",
            "text": "The  AbstractTranslatorHelper  view helper is used as a base abstract class for\nany helpers that need to translate content. It provides an implementation for\nthe  Zend\\I18n\\Translator\\TranslatorAwareInterface , allowing translator\ninjection as well as text domain injection.",
            "title": "Abstract Translator Helper"
        },
        {
            "location": "/view-helpers/#public-methods_4",
            "text": "",
            "title": "Public Methods"
        },
        {
            "location": "/view-helpers/#settranslator",
            "text": "setTranslator(\n    Translator $translator [ ,\n    string $textDomain = null\n] ) : void  Sets the  Zend\\I18n\\Translator\\Translator  instance to use in the helper. The $textDomain  argument is optional, and provided as a convenienct to allow\nsetting both the translator and text domain simultaneously.",
            "title": "setTranslator()"
        },
        {
            "location": "/view-helpers/#gettranslator",
            "text": "getTranslator() : Translator  Returns the  Zend\\I18n\\Translator\\Translator  instance used by the helper.",
            "title": "getTranslator()"
        },
        {
            "location": "/view-helpers/#hastranslator",
            "text": "hasTranslator() : bool  Returns true if the helper composes a  Zend\\I18n\\Translator\\Translator  instance.",
            "title": "hasTranslator()"
        },
        {
            "location": "/view-helpers/#settranslatorenabled",
            "text": "setTranslatorEnabled(bool $enabled) : void  Sets whether or not translations are enabled.",
            "title": "setTranslatorEnabled()"
        },
        {
            "location": "/view-helpers/#istranslatorenabled",
            "text": "isTranslatorEnabled() : bool  Returns true if translations are enabled.",
            "title": "isTranslatorEnabled()"
        },
        {
            "location": "/view-helpers/#settranslatortextdomain",
            "text": "setTranslatorTextDomain(string $textDomain) : void  Sets the default translation text domain to use with the helper.",
            "title": "setTranslatorTextDomain()"
        },
        {
            "location": "/view-helpers/#gettranslatortextdomain",
            "text": "getTranslatorTextDomain() : string  Returns the current text domain used by the helper.",
            "title": "getTranslatorTextDomain()"
        },
        {
            "location": "/filters/",
            "text": "Filters\n\n\nzend-i18n ships with a set of internationalization-related filters.\n\n\nAlnum\n\n\nThe \nAlnum\n filter can be used to return only alphabetic characters and digits in the unicode\n\"letter\" and \"number\" categories, respectively. All other characters are suppressed.\n\n\nSupported Options\n\n\nThe following options are supported for \nAlnum\n:\n\n\nAlnum([ boolean $allowWhiteSpace [, string $locale ]])\n\n\n\n\n\n\n$allowWhiteSpace\n: If set to true, whitespace characters are allowed;\n  otherwise they are suppressed. Default is \nfalse\n (whitespace is not allowed).\n  Methods for getting/setting the allowWhiteSpace option are also available\n  (\ngetAllowWhiteSpace()\n and \nsetAllowWhiteSpace()\n).\n\n\n$locale\n: The locale string used in identifying the characters to filter\n  (locale name, e.g.  \nen_US\n). If unset, it will use the default locale\n  (\nLocale::getDefault()\n). Methods for getting/setting the locale are also\n  available (\ngetLocale()\n and \nsetLocale()\n).\n\n\n\n\nBasic Usage\n\n\n// Default settings, deny whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alnum();\necho $filter->filter(\"This is (my) content: 123\");\n// Returns \"Thisismycontent123\"\n\n// First param in constructor is $allowWhiteSpace\n$filter = new \\Zend\\I18n\\Filter\\Alnum(true);\necho $filter->filter(\"This is (my) content: 123\");\n// Returns \"This is my content 123\"\n\n\n\n\n\n\nSupported languages\n\n\nAlnum\n works for most languages, except Chinese, Japanese and Korean. Within\nthese languages, the English alphabet is used instead of the characters from\nthese languages. The language itself is detected using the \nLocale\n class.\n\n\n\n\nAlpha\n\n\nThe \nAlpha\n filter can be used to return only alphabetic characters in the unicode \"letter\"\ncategory. All other characters are suppressed.\n\n\nSupported Options\n\n\nThe following options are supported for \nAlpha\n:\n\n\nAlpha([ boolean $allowWhiteSpace [, string $locale ]])\n\n\n\n\n\n\n$allowWhiteSpace\n: If set to true, whitespace characters are allowed;\n  otherwise they are suppressed. Default is \nfalse\n (whitespace is not allowed).\n  Methods for getting/setting the allowWhiteSpace option are also available\n  (\ngetAllowWhiteSpace()\n and \nsetAllowWhiteSpace()\n).\n\n\n$locale\n: The locale string used in identifying the characters to filter\n  (locale name, e.g.  \nen_US\n). If unset, it will use the default locale\n  (\nLocale::getDefault()\n). Methods for getting/setting the locale are also\n  available (\ngetLocale()\n and \nsetLocale()\n).\n\n\n\n\nBasic Usage\n\n\n// Default settings, deny whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alpha();\necho $filter->filter(\"This is (my) content: 123\");\n// Returns \"Thisismycontent\"\n\n// Allow whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alpha(true);\necho $filter->filter(\"This is (my) content: 123\");\n// Returns \"This is my content \"\n\n\n\n\n\n\nSupported languages\n\n\nAlnum\n works for most languages, except Chinese, Japanese and Korean. Within\nthese languages, the English alphabet is used instead of the characters from\nthese languages. The language itself is detected using the \nLocale\n class.\n\n\n\n\nNumberFormat\n\n\nThe \nNumberFormat\n filter can be used to return locale-specific number and\npercentage strings. It extends the \nNumberParse\n filter, which acts as wrapper\nfor the \nNumberFormatter\n class within ext/intl.\n\n\nSupported Options\n\n\nThe following options are supported for \nNumberFormat\n:\n\n\nNumberFormat([ string $locale [, int $style [, int $type ]]])\n\n\n\n\n\n\n$locale\n: The locale string used in identifying the characters to filter\n  (locale name, e.g.  \nen_US\n). If unset, it will use the default locale\n  (\nLocale::getDefault()\n). Methods for getting/setting the locale are also\n  available (\ngetLocale()\n and \nsetLocale()\n).\n\n\n$style\n: (Optional) Style of the formatting, one of the \nNumberFormatter\n\n  format style constants\n.\n  If unset, it will use \nNumberFormatter::DEFAULT_STYLE\n as the default style.\n  Methods for getting/setting the format style are also available (\ngetStyle()\n\n  and \nsetStyle()\n).\n\n\n$type\n: (Optional) The \nNumberFormatter\n formatting type\n\n  to use. If unset, it will use \nNumberFormatter::TYPE_DOUBLE\n as the default\n  type.  Methods for getting/setting the format type are also available\n  (\ngetType()\n and \nsetType()\n).\n\n\n\n\nBasic Usage\n\n\n$filter = new \\Zend\\I18n\\Filter\\NumberFormat('de_DE');\necho $filter->filter(1234567.8912346);\n// Returns \"1.234.567,891\"\n\n$filter = new \\Zend\\I18n\\Filter\\NumberFormat('en_US', NumberFormatter::PERCENT);\necho $filter->filter(0.80);\n// Returns \"80%\"\n\n$filter = new \\Zend\\I18n\\Filter\\NumberFormat('fr_FR', NumberFormatter::SCIENTIFIC);\necho $filter->filter(0.00123456789);\n// Returns \"1,23456789E-3\"\n\n\n\n\nNumberParse\n\n\nThe \nNumberParse\n filter can be used to parse a number from a string. It acts as\na wrapper for the \nNumberFormatter\n class within ext/intl.\n\n\nSupported Options\n\n\nThe following options are supported for \nNumberParse\n:\n\n\nNumberParse([ string $locale [, int $style [, int $type ]]])\n\n\n\n\n\n\n$locale\n: The locale string used in identifying the characters to filter\n  (locale name, e.g.  \nen_US\n). If unset, it will use the default locale\n  (\nLocale::getDefault()\n). Methods for getting/setting the locale are also\n  available (\ngetLocale()\n and \nsetLocale()\n).\n\n\n$style\n: (Optional) Style of the parsing, one of the \nNumberFormatter\n format style constants\n.\n  If unset, it will use \nNumberFormatter::DEFAULT_STYLE\n as the default style.\n  Methods for getting/setting the parse style are also available (\ngetStyle()\n\n  and \nsetStyle()\n).\n\n\n$type\n: (Optional) The \nNumberFormatter\n parsing type\n\n  to use. If unset, it will use \nNumberFormatter::TYPE_DOUBLE\n as the default\n  type.  Methods for getting/setting the parse type are also available\n  (\ngetType()\n and \nsetType()\n).\n\n\n\n\nBasic Usage\n\n\n$filter = new \\Zend\\I18n\\Filter\\NumberParse('de_DE');\necho $filter->filter('1.234.567,891');\n// Returns 1234567.8912346\n\n$filter = new \\Zend\\I18n\\Filter\\NumberParse('en_US', NumberFormatter::PERCENT);\necho $filter->filter('80%');\n// Returns 0.80\n\n$filter = new \\Zend\\I18n\\Filter\\NumberParse('fr_FR', NumberFormatter::SCIENTIFIC);\necho $filter->filter('1,23456789E-3');\n// Returns 0.00123456789",
            "title": "Filters"
        },
        {
            "location": "/filters/#filters",
            "text": "zend-i18n ships with a set of internationalization-related filters.",
            "title": "Filters"
        },
        {
            "location": "/filters/#alnum",
            "text": "The  Alnum  filter can be used to return only alphabetic characters and digits in the unicode\n\"letter\" and \"number\" categories, respectively. All other characters are suppressed.",
            "title": "Alnum"
        },
        {
            "location": "/filters/#supported-options",
            "text": "The following options are supported for  Alnum :  Alnum([ boolean $allowWhiteSpace [, string $locale ]])   $allowWhiteSpace : If set to true, whitespace characters are allowed;\n  otherwise they are suppressed. Default is  false  (whitespace is not allowed).\n  Methods for getting/setting the allowWhiteSpace option are also available\n  ( getAllowWhiteSpace()  and  setAllowWhiteSpace() ).  $locale : The locale string used in identifying the characters to filter\n  (locale name, e.g.   en_US ). If unset, it will use the default locale\n  ( Locale::getDefault() ). Methods for getting/setting the locale are also\n  available ( getLocale()  and  setLocale() ).",
            "title": "Supported Options"
        },
        {
            "location": "/filters/#basic-usage",
            "text": "// Default settings, deny whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alnum();\necho $filter->filter(\"This is (my) content: 123\");\n// Returns \"Thisismycontent123\"\n\n// First param in constructor is $allowWhiteSpace\n$filter = new \\Zend\\I18n\\Filter\\Alnum(true);\necho $filter->filter(\"This is (my) content: 123\");\n// Returns \"This is my content 123\"",
            "title": "Basic Usage"
        },
        {
            "location": "/filters/#supported-languages",
            "text": "Alnum  works for most languages, except Chinese, Japanese and Korean. Within\nthese languages, the English alphabet is used instead of the characters from\nthese languages. The language itself is detected using the  Locale  class.",
            "title": "Supported languages"
        },
        {
            "location": "/filters/#alpha",
            "text": "The  Alpha  filter can be used to return only alphabetic characters in the unicode \"letter\"\ncategory. All other characters are suppressed.",
            "title": "Alpha"
        },
        {
            "location": "/filters/#supported-options_1",
            "text": "The following options are supported for  Alpha :  Alpha([ boolean $allowWhiteSpace [, string $locale ]])   $allowWhiteSpace : If set to true, whitespace characters are allowed;\n  otherwise they are suppressed. Default is  false  (whitespace is not allowed).\n  Methods for getting/setting the allowWhiteSpace option are also available\n  ( getAllowWhiteSpace()  and  setAllowWhiteSpace() ).  $locale : The locale string used in identifying the characters to filter\n  (locale name, e.g.   en_US ). If unset, it will use the default locale\n  ( Locale::getDefault() ). Methods for getting/setting the locale are also\n  available ( getLocale()  and  setLocale() ).",
            "title": "Supported Options"
        },
        {
            "location": "/filters/#basic-usage_1",
            "text": "// Default settings, deny whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alpha();\necho $filter->filter(\"This is (my) content: 123\");\n// Returns \"Thisismycontent\"\n\n// Allow whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alpha(true);\necho $filter->filter(\"This is (my) content: 123\");\n// Returns \"This is my content \"",
            "title": "Basic Usage"
        },
        {
            "location": "/filters/#supported-languages_1",
            "text": "Alnum  works for most languages, except Chinese, Japanese and Korean. Within\nthese languages, the English alphabet is used instead of the characters from\nthese languages. The language itself is detected using the  Locale  class.",
            "title": "Supported languages"
        },
        {
            "location": "/filters/#numberformat",
            "text": "The  NumberFormat  filter can be used to return locale-specific number and\npercentage strings. It extends the  NumberParse  filter, which acts as wrapper\nfor the  NumberFormatter  class within ext/intl.",
            "title": "NumberFormat"
        },
        {
            "location": "/filters/#supported-options_2",
            "text": "The following options are supported for  NumberFormat :  NumberFormat([ string $locale [, int $style [, int $type ]]])   $locale : The locale string used in identifying the characters to filter\n  (locale name, e.g.   en_US ). If unset, it will use the default locale\n  ( Locale::getDefault() ). Methods for getting/setting the locale are also\n  available ( getLocale()  and  setLocale() ).  $style : (Optional) Style of the formatting, one of the  NumberFormatter \n  format style constants .\n  If unset, it will use  NumberFormatter::DEFAULT_STYLE  as the default style.\n  Methods for getting/setting the format style are also available ( getStyle() \n  and  setStyle() ).  $type : (Optional) The  NumberFormatter  formatting type \n  to use. If unset, it will use  NumberFormatter::TYPE_DOUBLE  as the default\n  type.  Methods for getting/setting the format type are also available\n  ( getType()  and  setType() ).",
            "title": "Supported Options"
        },
        {
            "location": "/filters/#basic-usage_2",
            "text": "$filter = new \\Zend\\I18n\\Filter\\NumberFormat('de_DE');\necho $filter->filter(1234567.8912346);\n// Returns \"1.234.567,891\"\n\n$filter = new \\Zend\\I18n\\Filter\\NumberFormat('en_US', NumberFormatter::PERCENT);\necho $filter->filter(0.80);\n// Returns \"80%\"\n\n$filter = new \\Zend\\I18n\\Filter\\NumberFormat('fr_FR', NumberFormatter::SCIENTIFIC);\necho $filter->filter(0.00123456789);\n// Returns \"1,23456789E-3\"",
            "title": "Basic Usage"
        },
        {
            "location": "/filters/#numberparse",
            "text": "The  NumberParse  filter can be used to parse a number from a string. It acts as\na wrapper for the  NumberFormatter  class within ext/intl.",
            "title": "NumberParse"
        },
        {
            "location": "/filters/#supported-options_3",
            "text": "The following options are supported for  NumberParse :  NumberParse([ string $locale [, int $style [, int $type ]]])   $locale : The locale string used in identifying the characters to filter\n  (locale name, e.g.   en_US ). If unset, it will use the default locale\n  ( Locale::getDefault() ). Methods for getting/setting the locale are also\n  available ( getLocale()  and  setLocale() ).  $style : (Optional) Style of the parsing, one of the  NumberFormatter  format style constants .\n  If unset, it will use  NumberFormatter::DEFAULT_STYLE  as the default style.\n  Methods for getting/setting the parse style are also available ( getStyle() \n  and  setStyle() ).  $type : (Optional) The  NumberFormatter  parsing type \n  to use. If unset, it will use  NumberFormatter::TYPE_DOUBLE  as the default\n  type.  Methods for getting/setting the parse type are also available\n  ( getType()  and  setType() ).",
            "title": "Supported Options"
        },
        {
            "location": "/filters/#basic-usage_3",
            "text": "$filter = new \\Zend\\I18n\\Filter\\NumberParse('de_DE');\necho $filter->filter('1.234.567,891');\n// Returns 1234567.8912346\n\n$filter = new \\Zend\\I18n\\Filter\\NumberParse('en_US', NumberFormatter::PERCENT);\necho $filter->filter('80%');\n// Returns 0.80\n\n$filter = new \\Zend\\I18n\\Filter\\NumberParse('fr_FR', NumberFormatter::SCIENTIFIC);\necho $filter->filter('1,23456789E-3');\n// Returns 0.00123456789",
            "title": "Basic Usage"
        },
        {
            "location": "/validators/",
            "text": "Validators\n\n\nzend-i18n provides a set of validators that use internationalization\ncapabilities.\n\n\nAlnum\n\n\nZend\\I18n\\Validator\\Alnum\n allows you to validate if a given value contains\nonly alphabetical characters and digits. There is no length limitation for the\ninput you want to validate.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\I18n\\Validator\\Alnum\n:\n\n\n\n\nallowWhiteSpace\n: Whether or not whitespace characters are allowed. This\n  option defaults to \nFALSE\n.\n\n\n\n\nBasic usage\n\n\n$validator = new Zend\\I18n\\Validator\\Alnum();\nif ($validator->isValid('Abcd12')) {\n    // value contains only allowed chars\n} else {\n    // false\n}\n\n\n\n\nUsing whitespace\n\n\nBy default, whitespace is not accepted as it is not part of the alphabet.\nHowever, if you want to validate complete sentences or phrases, you may need to\nallow whitespace; this can be done via the \nallowWhiteSpace\n option, either at\ninstantiation or afterwards via the \nsetAllowWhiteSpace()\n method.\n\n\nTo get the current state of the flag, use the \ngetAllowWhiteSpace()\n method.\n\n\n$validator = new Zend\\I18n\\Validator\\Alnum(['allowWhiteSpace' => true]);\n\n// or set it via method call:\n$validator->setAllowWhiteSpace(true);\n\nif ($validator->isValid('Abcd and 12')) {\n    // value contains only allowed chars\n} else {\n    // false\n}\n\n\n\n\nUsing different languages\n\n\nSeveral languages supported by ext/intl use alphabets where characters are\nformed from multiple bytes, including \nKorean\n, \nJapanese\n, and \nChinese\n. Such\nlanguages therefore are unsupported with regards to the \nAlnum\n validator.\n\n\nWhen using the \nAlnum\n validator with these langauges, the input will be validated\nusing the English alphabet.\n\n\nAlpha\n\n\nZend\\I18n\\Validator\\Alpha\n allows you to validate if a given value contains\nonly alphabetical characters. There is no length limitation for the input you\nwant to validate. This validator is identical to the \nZend\\I18n\\Validator\\Alnum\n\nvalidator with the exception that it does not accept digits.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\I18n\\Validator\\Alpha\n:\n\n\n\n\nallowWhiteSpace\n: Whether or not whitespace characters are allowed. This\n  option defaults to \nFALSE\n.\n\n\n\n\nBasic usage\n\n\n$validator = new Zend\\I18n\\Validator\\Alpha();\nif ($validator->isValid('Abcd')) {\n    // value contains only allowed chars\n} else {\n    // false\n}\n\n\n\n\nUsing whitespace\n\n\nBy default, whitespace is not accepted as it is not part of the alphabet.\nHowever, if you want to validate complete sentences or phrases, you may need to\nallow whitespace; this can be done via the \nallowWhiteSpace\n option, either at\ninstantiation or afterwards via the \nsetAllowWhiteSpace()\n method.\n\n\nTo get the current state of the flag, use the \ngetAllowWhiteSpace()\n method.\n\n\n$validator = new Zend\\I18n\\Validator\\Alpha(['allowWhiteSpace' => true]);\n\n// or set it via method call:\n$validator->setAllowWhiteSpace(true);\n\nif ($validator->isValid('Abcd and efg')) {\n    // value contains only allowed chars\n} else {\n    // false\n}\n\n\n\n\nUsing different languages\n\n\nWhen using \nZend\\I18n\\Validator\\Alpha\n, the language provided by the user's\nbrowser will be used to set the allowed characters. For locales outside of\nEnglish, this means that additional alphabetic characters may be used\n\u2014 such as \n\u00e4\n, \n\u00f6\n and \n\u00fc\n from the German alphabet.\n\n\nWhich characters are allowed depends completely on the language, as every\nlanguage defines its own set of characters.\n\n\nThree languages supported by ext/intl, however, define multibyte characters,\nwhich cannot be matched as alphabetic characters using normal string or regular\nexpression options. These include \nKorean\n, \nJapanese\n, and \nChinese\n.\n\n\nAs a result, when using the \nAlpha\n validator with these langauges, the input\nwill be validated using the English alphabet.\n\n\nIsFloat\n\n\nZend\\I18n\\Validator\\IsFloat\n allows you to validate if a given value contains a\nfloating-point value. This validator takes into account localized input.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\I18n\\Validator\\IsFloat\n:\n\n\n\n\nlocale\n: Sets the locale to use when validating localized float values.\n\n\n\n\nBasic float validation\n\n\nBy default, if no locale is provided, \nIsFloat\n will use the system locale.\n\n\n$validator = new Zend\\I18n\\Validator\\IsFloat();\n\n$validator->isValid(1234.5);    // returns true\n$validator->isValid('10a01');   // returns false\n$validator->isValid('1,234.5'); // returns true\n\n\n\n\n(The above example assumes that the environment locale is set to \nen\n.)\n\n\nLocalized float validation\n\n\nFloat values are often written differently based on the country or region. For\nexample, using English, you might write \n1.5\n, whereas in german you would write\n\n1,5\n, and in other languages you might use grouping.\n\n\nZend\\I18n\\Validator\\IsFloat\n is able to validate such notations. However, it is\nlimited to the locale you set. See the following code:\n\n\n$validator = new Zend\\I18n\\Validator\\IsFloat(['locale' => 'de']);\n\n$validator->isValid(1234.5);    // returns true\n$validator->isValid(\"1 234,5\"); // returns false\n$validator->isValid(\"1.234\");   // returns true\n\n\n\n\nBy using a locale, your input is validated based on the locale provided. Using a\nnotation not specific to the locale results in a \nfalse\n evaulation.\n\n\nThe default validation locale can also be set after instantiation using\n\nsetLocale()\n, and retrieved using \ngetLocale()\n.\n\n\nMigration from 2.0-2.3 to 2.4+\n\n\nVersion 2.4 adds support for PHP 7. In PHP 7, \nfloat\n is a reserved keyword,\nwhich required renaming the \nFloat\n validator. If you were using the \nFloat\n\nvalidator directly previously, you will now receive an \nE_USER_DEPRECATED\n\nnotice on instantiation. Please update your code to refer to the \nIsFloat\n class\ninstead.\n\n\nUsers pulling their \nFloat\n validator instance from the validator plugin manager\nreceive an \nIsFloat\n instance instead starting in 2.4.0.\n\n\nIsInt\n\n\nZend\\I18n\\Validator\\IsInt\n validates if a given value is an integer, using the\nlocale provided.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\I18n\\Validator\\IsInt\n:\n\n\n\n\nlocale\n: Sets the locale to use when validating localized integers.\n\n\n\n\nBasic integer validation\n\n\nWhen no locale is provided to the validator, it uses the system locale:\n\n\n$validator = new Zend\\I18n\\Validator\\IsInt();\n\n$validator->isValid(1234);    // returns true\n$validator->isValid(1234.5);  // returns false\n$validator->isValid('1,234'); // returns true\n\n\n\n\n(The above example assumes that the environment locale is set to \nen\n.)\n\n\nLocalized integer validation\n\n\nInteger values are often written differently based on country or region. For\nexample, using English, you may write \"1234\" or \"1,234\"; both are integer\nvalues, but the grouping is optional. In German, you'd write \"1.234\", and in\nFrench, \"1 234\".\n\n\nZend\\I18n\\Validator\\IsInt\n will use a provided locale when evaluating the\nvalidity of an integer value. In such cases, it doesn't simply strip the\nvalidator, but instead validates that the correct separator as defined by the\nlocale is used.\n\n\n$validator = new Zend\\I18n\\Validator\\IsInt(['locale' => 'de']);\n\n$validator->isValid(1234);    // returns true\n$validator->isValid(\"1,234\"); // returns false\n$validator->isValid(\"1.234\"); // returns true\n\n\n\n\nBy using a locale, your input is validated based on the locale provided. Using a\nnotation not specific to the locale results in a \nfalse\n evaulation.\n\n\nThe default validation locale can also be set after instantiation using\n\nsetLocale()\n, and retrieved using \ngetLocale()\n.\n\n\nMigration from 2.0-2.3 to 2.4+\n\n\nVersion 2.4 adds support for PHP 7. In PHP 7, \nint\n is a reserved keyword, which\nrequired renaming the \nInt\n validator. If you were using the \nInt\n validator\ndirectly previously, you will now receive an \nE_USER_DEPRECATED\n notice on\ninstantiation. Please update your code to refer to the \nIsInt\n class instead.\n\n\nUsers pulling their \nInt\n validator instance from the validator plugin manager\nreceive an \nIsInt\n instance instead starting in 2.4.0.",
            "title": "Validators"
        },
        {
            "location": "/validators/#validators",
            "text": "zend-i18n provides a set of validators that use internationalization\ncapabilities.",
            "title": "Validators"
        },
        {
            "location": "/validators/#alnum",
            "text": "Zend\\I18n\\Validator\\Alnum  allows you to validate if a given value contains\nonly alphabetical characters and digits. There is no length limitation for the\ninput you want to validate.",
            "title": "Alnum"
        },
        {
            "location": "/validators/#supported-options",
            "text": "The following options are supported for  Zend\\I18n\\Validator\\Alnum :   allowWhiteSpace : Whether or not whitespace characters are allowed. This\n  option defaults to  FALSE .",
            "title": "Supported options"
        },
        {
            "location": "/validators/#basic-usage",
            "text": "$validator = new Zend\\I18n\\Validator\\Alnum();\nif ($validator->isValid('Abcd12')) {\n    // value contains only allowed chars\n} else {\n    // false\n}",
            "title": "Basic usage"
        },
        {
            "location": "/validators/#using-whitespace",
            "text": "By default, whitespace is not accepted as it is not part of the alphabet.\nHowever, if you want to validate complete sentences or phrases, you may need to\nallow whitespace; this can be done via the  allowWhiteSpace  option, either at\ninstantiation or afterwards via the  setAllowWhiteSpace()  method.  To get the current state of the flag, use the  getAllowWhiteSpace()  method.  $validator = new Zend\\I18n\\Validator\\Alnum(['allowWhiteSpace' => true]);\n\n// or set it via method call:\n$validator->setAllowWhiteSpace(true);\n\nif ($validator->isValid('Abcd and 12')) {\n    // value contains only allowed chars\n} else {\n    // false\n}",
            "title": "Using whitespace"
        },
        {
            "location": "/validators/#using-different-languages",
            "text": "Several languages supported by ext/intl use alphabets where characters are\nformed from multiple bytes, including  Korean ,  Japanese , and  Chinese . Such\nlanguages therefore are unsupported with regards to the  Alnum  validator.  When using the  Alnum  validator with these langauges, the input will be validated\nusing the English alphabet.",
            "title": "Using different languages"
        },
        {
            "location": "/validators/#alpha",
            "text": "Zend\\I18n\\Validator\\Alpha  allows you to validate if a given value contains\nonly alphabetical characters. There is no length limitation for the input you\nwant to validate. This validator is identical to the  Zend\\I18n\\Validator\\Alnum \nvalidator with the exception that it does not accept digits.",
            "title": "Alpha"
        },
        {
            "location": "/validators/#supported-options_1",
            "text": "The following options are supported for  Zend\\I18n\\Validator\\Alpha :   allowWhiteSpace : Whether or not whitespace characters are allowed. This\n  option defaults to  FALSE .",
            "title": "Supported options"
        },
        {
            "location": "/validators/#basic-usage_1",
            "text": "$validator = new Zend\\I18n\\Validator\\Alpha();\nif ($validator->isValid('Abcd')) {\n    // value contains only allowed chars\n} else {\n    // false\n}",
            "title": "Basic usage"
        },
        {
            "location": "/validators/#using-whitespace_1",
            "text": "By default, whitespace is not accepted as it is not part of the alphabet.\nHowever, if you want to validate complete sentences or phrases, you may need to\nallow whitespace; this can be done via the  allowWhiteSpace  option, either at\ninstantiation or afterwards via the  setAllowWhiteSpace()  method.  To get the current state of the flag, use the  getAllowWhiteSpace()  method.  $validator = new Zend\\I18n\\Validator\\Alpha(['allowWhiteSpace' => true]);\n\n// or set it via method call:\n$validator->setAllowWhiteSpace(true);\n\nif ($validator->isValid('Abcd and efg')) {\n    // value contains only allowed chars\n} else {\n    // false\n}",
            "title": "Using whitespace"
        },
        {
            "location": "/validators/#using-different-languages_1",
            "text": "When using  Zend\\I18n\\Validator\\Alpha , the language provided by the user's\nbrowser will be used to set the allowed characters. For locales outside of\nEnglish, this means that additional alphabetic characters may be used\n\u2014 such as  \u00e4 ,  \u00f6  and  \u00fc  from the German alphabet.  Which characters are allowed depends completely on the language, as every\nlanguage defines its own set of characters.  Three languages supported by ext/intl, however, define multibyte characters,\nwhich cannot be matched as alphabetic characters using normal string or regular\nexpression options. These include  Korean ,  Japanese , and  Chinese .  As a result, when using the  Alpha  validator with these langauges, the input\nwill be validated using the English alphabet.",
            "title": "Using different languages"
        },
        {
            "location": "/validators/#isfloat",
            "text": "Zend\\I18n\\Validator\\IsFloat  allows you to validate if a given value contains a\nfloating-point value. This validator takes into account localized input.",
            "title": "IsFloat"
        },
        {
            "location": "/validators/#supported-options_2",
            "text": "The following options are supported for  Zend\\I18n\\Validator\\IsFloat :   locale : Sets the locale to use when validating localized float values.",
            "title": "Supported options"
        },
        {
            "location": "/validators/#basic-float-validation",
            "text": "By default, if no locale is provided,  IsFloat  will use the system locale.  $validator = new Zend\\I18n\\Validator\\IsFloat();\n\n$validator->isValid(1234.5);    // returns true\n$validator->isValid('10a01');   // returns false\n$validator->isValid('1,234.5'); // returns true  (The above example assumes that the environment locale is set to  en .)",
            "title": "Basic float validation"
        },
        {
            "location": "/validators/#localized-float-validation",
            "text": "Float values are often written differently based on the country or region. For\nexample, using English, you might write  1.5 , whereas in german you would write 1,5 , and in other languages you might use grouping.  Zend\\I18n\\Validator\\IsFloat  is able to validate such notations. However, it is\nlimited to the locale you set. See the following code:  $validator = new Zend\\I18n\\Validator\\IsFloat(['locale' => 'de']);\n\n$validator->isValid(1234.5);    // returns true\n$validator->isValid(\"1 234,5\"); // returns false\n$validator->isValid(\"1.234\");   // returns true  By using a locale, your input is validated based on the locale provided. Using a\nnotation not specific to the locale results in a  false  evaulation.  The default validation locale can also be set after instantiation using setLocale() , and retrieved using  getLocale() .",
            "title": "Localized float validation"
        },
        {
            "location": "/validators/#migration-from-20-23-to-24",
            "text": "Version 2.4 adds support for PHP 7. In PHP 7,  float  is a reserved keyword,\nwhich required renaming the  Float  validator. If you were using the  Float \nvalidator directly previously, you will now receive an  E_USER_DEPRECATED \nnotice on instantiation. Please update your code to refer to the  IsFloat  class\ninstead.  Users pulling their  Float  validator instance from the validator plugin manager\nreceive an  IsFloat  instance instead starting in 2.4.0.",
            "title": "Migration from 2.0-2.3 to 2.4+"
        },
        {
            "location": "/validators/#isint",
            "text": "Zend\\I18n\\Validator\\IsInt  validates if a given value is an integer, using the\nlocale provided.",
            "title": "IsInt"
        },
        {
            "location": "/validators/#supported-options_3",
            "text": "The following options are supported for  Zend\\I18n\\Validator\\IsInt :   locale : Sets the locale to use when validating localized integers.",
            "title": "Supported Options"
        },
        {
            "location": "/validators/#basic-integer-validation",
            "text": "When no locale is provided to the validator, it uses the system locale:  $validator = new Zend\\I18n\\Validator\\IsInt();\n\n$validator->isValid(1234);    // returns true\n$validator->isValid(1234.5);  // returns false\n$validator->isValid('1,234'); // returns true  (The above example assumes that the environment locale is set to  en .)",
            "title": "Basic integer validation"
        },
        {
            "location": "/validators/#localized-integer-validation",
            "text": "Integer values are often written differently based on country or region. For\nexample, using English, you may write \"1234\" or \"1,234\"; both are integer\nvalues, but the grouping is optional. In German, you'd write \"1.234\", and in\nFrench, \"1 234\".  Zend\\I18n\\Validator\\IsInt  will use a provided locale when evaluating the\nvalidity of an integer value. In such cases, it doesn't simply strip the\nvalidator, but instead validates that the correct separator as defined by the\nlocale is used.  $validator = new Zend\\I18n\\Validator\\IsInt(['locale' => 'de']);\n\n$validator->isValid(1234);    // returns true\n$validator->isValid(\"1,234\"); // returns false\n$validator->isValid(\"1.234\"); // returns true  By using a locale, your input is validated based on the locale provided. Using a\nnotation not specific to the locale results in a  false  evaulation.  The default validation locale can also be set after instantiation using setLocale() , and retrieved using  getLocale() .",
            "title": "Localized integer validation"
        },
        {
            "location": "/validators/#migration-from-20-23-to-24_1",
            "text": "Version 2.4 adds support for PHP 7. In PHP 7,  int  is a reserved keyword, which\nrequired renaming the  Int  validator. If you were using the  Int  validator\ndirectly previously, you will now receive an  E_USER_DEPRECATED  notice on\ninstantiation. Please update your code to refer to the  IsInt  class instead.  Users pulling their  Int  validator instance from the validator plugin manager\nreceive an  IsInt  instance instead starting in 2.4.0.",
            "title": "Migration from 2.0-2.3 to 2.4+"
        }
    ]
}